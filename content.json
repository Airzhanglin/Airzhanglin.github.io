[{"title":"人脸识别","date":"2020-09-07T06:19:05.000Z","path":"2020/09/07/faceLogin/","text":"之前项目中用过人脸识别，主要是js调用器摄像头，通过利用canvas画布将视频当前帧转换成图片的实例，其中用到了 mediaDevices.getUserMedia 方法。合成的图片发送给后台要后台去做活体检测。功能实现没问题，但是前端都是只能靠点击一个按钮来拍照，实现的太傻瓜。后来在掘金上看到一个大佬利用tracking来实现前端部分功能，改库只对人脸有效，而且能够框住人脸和跟踪，于是跟着文章自己实现了一遍。 开发1、找个架子 我使用的[vue-cli3.0][1]来，快速搭建模板，而且官方的较为标准，有问题也可以在网上找到答案。 2、插件tracking.js Tracking.js 是一个独立的JavaScript库，用于跟踪从相机实时收到的数据。跟踪的数据既可以是颜色，也可以是人，也就是说我们可以通过检测到某特定颜色，或者检测一个人体/脸的出现与移动，来触发JavaScript 事件。它是非常易于使用的API，具有数个方法和事件（足够使用了）。 传送门 tracking.js 3、插件face-api.js 是一个 JavaScript API，是基于 tensorflow.js 核心 API 的人脸检测和人脸识别的浏览器实现。它实现了一系列的卷积神经网络（CNN），针对网络和移动设备进行了优化 4、引入js 下载两个文件后 在index.html引入12&lt;script src=\"./tracking-min.js\"&gt;&lt;/script&gt;&lt;script src=\"./face-min.js\"&gt;&lt;/script&gt; 5、设计流程 调用摄像头 检测摄像头中是否有人脸 如果有人脸在画面中画出canvas层 导出base64图片 把图片发送给后端进行人脸叫人 获得返回接口 6、HTML结构 123456789101112&lt;template&gt; &lt;div class=\"container\"&gt; &lt;div class=\"face-box\"&gt; &lt;video id=\"_videoFace\" width=\"375\" height=\"200\" preload autoPlay loop muted /&gt; &lt;canvas id=\"_canvasFace\" class=\"face-canvas\" width=\"375\" height=\"200\" /&gt; &lt;/div&gt; &lt;div style='none'&gt; &lt;p&gt;实时截图&lt;/p&gt; &lt;canvas id=\"_canvas2Face\" width=\"375\" height=\"200\" /&gt; &lt;/div&gt; &lt;/div&gt;&lt;/template&gt; 7、js部分 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657const tracking = window.tracking;// index.html引入的，window全局可以拿到let video,canvas,canvas2,context,context2 export default &#123; data() &#123; return &#123; canvas: '', canvas2: '', context: '', context2: '', timer:true &#125; &#125;, mounted() &#123; this.initFace() &#125;, methods: &#123; initFace() &#123; video = document.getElementById('_videoFace'); canvas = document.getElementById('_canvasFace'); canvas2 = document.getElementById('_canvas2Face'); context = canvas.getContext('2d'); context2 = canvas2.getContext('2d'); const tracker = new tracking.ObjectTracker('face'); tracker.setInitialScale(4); tracker.setStepSize(1); tracker.setEdgesDensity(0.1); tracking.track('#_videoFace', tracker, &#123; camera: true &#125;); tracker.on('track', (event) =&gt; &#123; // no-face if (event.data.length === 0) return; // debounce if (this.timer) &#123; this.draw(event) this.timer = false; setTimeout(() =&gt; &#123; this.timer = true; &#125;, 0) &#125; &#125;); &#125;, draw(event) &#123; context.clearRect(0, 0, canvas.width, canvas.height); event.data.forEach((rect) =&gt; &#123; context.strokeStyle = '#10ff87'; context.strokeRect(rect.x, rect.y, rect.width, rect.height); context.font = '11px Helvetica'; context.fillStyle = \"#fff\"; context.fillText(\"x:\" + rect.x + 'px', rect.x + rect.width + 5, rect.y + 11); context.fillText('y: ' + rect.y + 'px', rect.x + rect.width + 5, rect.y + 22); &#125;); context2.drawImage(video, 0, 0, 200, 150); const snapData = canvas2.toDataURL('image/png'); const imgSrc = \"data:image/png;\" + snapData; this.$emit('change',imgSrc) &#125; &#125;,&#125; 8、效果 仓库地址：https://github.com/airzhanglin/vueFace 效果展示：https://demo.zhanglin168.cn/face.html","tags":[{"name":"tracking 、face","slug":"tracking-、face","permalink":"http://yoursite.com/tags/tracking-、face/"}]},{"title":"常用正则","date":"2020-09-07T03:05:51.000Z","path":"2020/09/07/regular/","text":"开发中常常会碰到一些验证，自己随手记录下来，方便后面开发，省下时间来更多的去关注业务技术和功能点 1. 只能输入数字 1234567891011121314151617&lt;el-input v-model.trim=\"mobile\" placeholder=\"请输入手机号码\" @input=\"handleInput('mobile')\" /&gt;&lt;script&gt; export default&#123; data()&#123; return&#123; mobile:'' &#125; &#125;, method:&#123; handleInput(key) &#123; // 只能输入数字控制 this.formData[key] = this.formData[key].replace(/[^\\.\\d]/g, '') this.formData[key] = this.formData[key].replace('.', '') &#125;, &#125; &#125;&lt;/script&gt; 2. 只能输入字母和数字 或汉字 123456789101112131415161718192021&lt;el-input v-model.trim=\"formData.empCode\" placeholder=\"请输入员工编码\" @input=\"handleInput('empCode')\" /&gt; &lt;script&gt; export default&#123; data()&#123; return&#123; empCode:'' &#125; &#125;, method:&#123; handleInput(key) &#123; // 限制只能输入字母 和数字 this[key] = this[key].replace(/[^\\a-\\z\\A-\\Z0-9]/ig, '') // 限制只能输入字母 汉字 数字 this[key] = this[key].replace(/[^\\a-\\z\\A-\\Z0-9\\u4E00-\\u9FA5]/g, '') &#125;, &#125; &#125; &lt;/script&gt; 3. 密码 123456var pattern = /^(?=.*[A-Za-z])(?=.*\\d)(?=.*[$@$!%*#?&amp;])[A-Za-z\\d$@$!%*#?&amp;]&#123;8,&#125;$/if(pattern.test('131231'))&#123; console.log(请输入至少8个字符，至少1个字母，1个数字和1个特殊字符的密码) &#125;","tags":[{"name":"正则","slug":"正则","permalink":"http://yoursite.com/tags/正则/"}]},{"title":"使用Verdaccio搭建npm私有服务","date":"2019-10-08T09:00:00.000Z","path":"2019/10/08/verdaccio/","text":"一、 为什么需要搭建npm私有服务 如果公司处于隐私保护的需要，不想讲自己封的包推到npm社区，但又急需要一套完整的包管理工具来管理越来越多的组件，模块，项目。对于前端，最熟悉的莫过于npm，npm是前端包管理的不二选择 使用 NPM 装包的时候下载速度慢如龟速，所以解决办法是使用cnpm淘宝镜像来装包加速，但有比淘宝更快的方法是从局域网的私服下。 我们想在下载的时候，私有的包用公司内部的服务器，公共的包走公共仓库 二、 常用搭建私有 NPM 服务方式 Sinopia Verdaccio 目前Sinopia已经在2015年10月后停止了丢 sinopia 的维护和升级，所以我推荐使用verdaccio来搭建npm私有服务 搭建过程1. 安装node环境123456 //下载node安装包到指定目录 wget https://npm.taobao.org/mirrors/node/v11.0.0/node-v11.0.0.tar.gz// 解压安装tar -xvf node-v11.0.0.tar.gz linux详细安装node教程点击 2. 安装verdaccio使用npm或者cnpm安装，需要权限在npm 前面加sudo1npm install -g verdaccio 基本使用 一旦安装后，您只需要执行命令： 123 $&gt; verdacciowarn --- config file - /home/.config/verdaccio/config.yamlwarn --- http address - http://localhost:4873/ - verdaccio/3.0.0 可以使用pm2来管理进程,安装好pm2之后: # 启动 sudo pm2 start verdaccio # 关闭 pm2 stop verdaccio 修改verdaccio配置//执行如下命令修改配置，可以修改镜像源1$&gt; vi /home/.config/verdaccio/config.yaml 由于 verdaccio 默认使用的是npm官方的源，你可以改成淘宝的源 他的配置文件在 /home/.config/verdaccio/config.yaml 其中有个 uplinks 字段 uplinks: npmjs: url: https://registry.npmjs.org/ 将 url 改为 https://registry.npm.taobao.org/ 即可 开发中如何使用 本地开发中修改npm镜像源 npm set registry http://localhost:4873/ 你也可以在下载的时候带上参数 –registry npm install --registry http://localhost:4873 方便起见，可以在项目目录下新建 .npmrc 文件，写入如下内容： registry=http://localhost:4873 然后项目安装的包就会先从你自己的npm下载，如果找不到就会找官方npm源 注意：http://localhost:4873指示本地运行的，部署在服务器的时候使用ip或者域名即可 verdaccio 文档 如何发布包发布自己的包可以在网上找到很多资料，这里就不讲述了。构建完自己的包之后，发布到私有服务中，一下命令 # 注册用户 npm adduser –registry http://localhost:4873 #查看当前用户,是否是注册用户. npm who am i # 发布 npm push","tags":[{"name":"Verdaccio","slug":"Verdaccio","permalink":"http://yoursite.com/tags/Verdaccio/"}]},{"title":"开发常用Js 工具函数及方法（一）","date":"2018-09-06T13:12:16.000Z","path":"2018/09/06/tool/","text":"工作常用的js方法，开发中方便边记录下来。 1.查找数组中某个对象中属性所在的位置123456789101112131415161718192021222324252627282930313233343536/** * * 查找数组，返回匹配到的第一个index * * @param array 被查找的数组 * @param feature 查找特征 或者为一个具体值，用于匹配数组遍历的值，或者为一个对象，表明所有希望被匹配的key-value * @param or boolean 希望命中feature全部特征或者只需命中一个特征，默认true * * @return 数组下标 查找不到返回-1 */function findArray(array, feature) &#123; var all = arguments.length &gt; 2 &amp;&amp; arguments[2] !== undefined ? arguments[2] : true; for (var index in array) &#123; var cur = array[index]; if (feature instanceof Object) &#123; var allRight = true; for (var key in feature) &#123; var value = feature[key]; if (cur[key] == value &amp;&amp; !all) return index; if (all &amp;&amp; cur[key] != value) &#123; allRight = false; break; &#125; &#125; if (allRight) return index; &#125; else &#123; if (cur == feature) &#123; return index; &#125; &#125; &#125; return -1;&#125;//使用方法var list=[&#123;id:1,name:'a'&#125;,&#123;id:2,name:'b'&#125;],findIndex = findArray(list,&#123;id:1&#125;) 2. 判断是否在微信、uc/qq浏览器中打开页面12345678910var ua = window.navigator.userAgent.toLowerCase(); if(ua.match(/MicroMessenger/i) == 'micromessenger')&#123; alert('微信'); &#125; if(navigator.userAgent.indexOf('UCBrowser') &gt; -1) &#123; alert(\"uc浏览器\"); &#125; if(navigator.userAgent.indexOf('QQBrowser') &gt; -1) &#123; alert(\"qq浏览器\"); &#125; 3. 判断是设备123456789101112131415161718192021222324//判断设备function IsPC() &#123; var userAgentInfo = navigator.userAgent; var Agents = [\"Android\", \"iPhone\", \"SymbianOS\", \"Windows Phone\", \"iPad\", \"iPod\"]; var flag = true; for (var v = 0; v &lt; Agents.length; v++) &#123; if (userAgentInfo.indexOf(Agents[v]) &gt; 0) &#123; flag = false; break; &#125; &#125; return flag;&#125; var flag = IsPC(); //true为PC端，false为手机端//判断是ios设备还是Android设备 var ua = navigator.userAgent.toLowerCase();//获取当前设备信息 if (/iphone|ipad|ipod/.test(ua)) &#123;//如果是ios &#125; else if (/android/.test(ua)) &#123;//安卓 &#125; 4.时间戳和日期字符串相互转换12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 获取当前时间戳(以s为单位)var timestamp = Date.parse(new Date());timestamp = timestamp / 1000;//当前时间戳为：1403149534console.log(\"当前时间戳为：\" + timestamp);// 获取某个时间格式的时间戳var stringTime = \"2014-07-10 10:21:12\";var timestamp2 = Date.parse(new Date(stringTime));// 如果想获取的时间戳为13位那就不用除1000timestamp2 = timestamp2 / 1000;//2014-07-10 10:21:12的时间戳为：1404958872 console.log(stringTime + \"的时间戳为：\" + timestamp2);// 将当前时间换成时间格式字符串var timestamp3 = 1403058804;var newDate = new Date();newDate.setTime(timestamp3 * 1000);// Wed Jun 18 2014 console.log(newDate.toDateString());// Wed, 18 Jun 2014 02:33:24 GMT console.log(newDate.toGMTString());// 2014-06-18T02:33:24.000Zconsole.log(newDate.toISOString());// 2014-06-18T02:33:24.000Z console.log(newDate.toJSON());// 2014年6月18日 console.log(newDate.toLocaleDateString());// 2014年6月18日 上午10:33:24 console.log(newDate.toLocaleString());// 上午10:33:24 console.log(newDate.toLocaleTimeString());// Wed Jun 18 2014 10:33:24 GMT+0800 (中国标准时间)console.log(newDate.toString());// 10:33:24 GMT+0800 (中国标准时间) console.log(newDate.toTimeString());// Wed, 18 Jun 2014 02:33:24 GMTconsole.log(newDate.toUTCString());Date.prototype.format = function(format) &#123; var date = &#123; \"M+\": this.getMonth() + 1, \"d+\": this.getDate(), \"h+\": this.getHours(), \"m+\": this.getMinutes(), \"s+\": this.getSeconds(), \"q+\": Math.floor((this.getMonth() + 3) / 3), \"S+\": this.getMilliseconds() &#125;; if (/(y+)/i.test(format)) &#123; format = format.replace(RegExp.$1, (this.getFullYear() + '').substr(4 - RegExp.$1.length)); &#125; for (var k in date) &#123; if (new RegExp(\"(\" + k + \")\").test(format)) &#123; format = format.replace(RegExp.$1, RegExp.$1.length == 1 ? date[k] : (\"00\" + date[k]).substr((\"\" + date[k]).length)); &#125; &#125; return format;&#125;console.log(newDate.format('yyyy-MM-dd h:m:s')); 时间戳转日期工具 6. 时间差计算123456789101112131415161718192021222324252627282930313233function timeAgo()&#123; let timetamp = dateTimeStamp.replace(/\\-/g, &quot;/&quot;) let minute = 1000 * 60 let hour = minute * 60 let day = hour * 24 let month = day * 30 let now = new Date().getTime() let diffValue = now - (parseInt(Date.parse(new Date(timetamp)))) if (diffValue &lt; 0) &#123; // alert(&apos;结束日期不能小于开始日期！&apos;) &#125; let monthC = diffValue / month let weekC = diffValue / (7 * day) let dayC = diffValue / day let hourC = diffValue / hour let minC = diffValue / minute let result if (monthC &gt;= 1) &#123; result = parseInt(monthC) + &apos;个月前&apos; &#125; else if (weekC &gt;= 1) &#123; result = parseInt(weekC) + &apos;周前&apos; &#125; else if (dayC &gt;= 1) &#123; result = parseInt(dayC) + &apos;天前&apos; &#125; else if (hourC &gt;= 1) &#123; result = parseInt(hourC) + &apos;个小时前&apos; &#125; else if (minC &gt;= 1) &#123; result = parseInt(minC) + &apos;分钟前&apos; &#125; else &#123; result = &apos;刚刚&apos; &#125; return result&#125;timeAgo(&apos;2018-08-20 16:39:05&apos;) 7. 获取地址栏参数12345678910111213/** * js正则获取地址栏的参数值（key -- value） */function GetQueryString(name) &#123; var reg = new RegExp(\"(^|&amp;)\" + name + \"=([^&amp;]*)(&amp;|$)\"); var r = window.location.search.substr(1).match(reg); if (r != null) return unescape(r[2]); return null;&#125;//使用var path = http://www.baidu.com?id=1;console.log(GetQueryString(id));// 1 8.常用正则123456789101112131415161718192021222324252627282930313233343536373839//邮箱校验function emailCheck(email)&#123; let reg = /^([0-9A-Za-z\\-_\\.]+)@([0-9a-z]+\\.[a-z]&#123;2,3&#125;(\\.[a-z]&#123;2&#125;)?)$/g; if (!reg.test(email)) &#123; return false; &#125; else &#123; return true; &#125;&#125;//手机号码校验function phoneCheck(value)&#123; let telreg = /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/; if(!telreg.test(value))&#123; return false; &#125; else &#123; return true; &#125;&#125;//座机号码校验function telphone()&#123; var regex = /^0\\d&#123;2,3&#125;-?\\d&#123;7,8&#125;$/; if (!regex.test(val)) &#123; return false &#125;else&#123; return true; &#125;&#125;//6-20密码 数字和字母组成的密码function passwordCheck(value)&#123; var reg = /^[1][3,4,5,7,8][0-9]&#123;9&#125;$/; if(!reg.test(value))&#123; return false; &#125; else &#123; return true; &#125;&#125; 9. 身份证校验123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384function IdentityCodeValid(code)&#123; var city = &#123; 11: \"北京\", 12: \"天津\", 13: \"河北\", 14: \"山西\", 15: \"内蒙古\", 21: \"辽宁\", 22: \"吉林\", 23: \"黑龙江 \", 31: \"上海\", 32: \"江苏\", 33: \"浙江\", 34: \"安徽\", 35: \"福建\", 36: \"江西\", 37: \"山东\", 41: \"河南\", 42: \"湖北 \", 43: \"湖南\", 44: \"广东\", 45: \"广西\", 46: \"海南\", 50: \"重庆\", 51: \"四川\", 52: \"贵州\", 53: \"云南\", 54: \"西藏 \", 61: \"陕西\", 62: \"甘肃\", 63: \"青海\", 64: \"宁夏\", 65: \"新疆\", 71: \"台湾\", 81: \"香港\", 82: \"澳门\", 91: \"国外 \" &#125;; var tip = \"\"; var pass = true; if (code === \"\") &#123; return true; &#125; if ( !code || !/^\\d&#123;6&#125;(18|19|20)?\\d&#123;2&#125;(0[1-9]|1[012])(0[1-9]|[12]\\d|3[01])\\d&#123;3&#125;(\\d|X)$/i.test( code ) ) &#123; tip = \"身份证号格式错误\"; pass = false; &#125; else if (!city[code.substr(0, 2)]) &#123; tip = \"地址编码错误\"; pass = false; &#125; else &#123; //18位身份证需要验证最后一位校验位 if (code.length == 18) &#123; code = code.split(\"\"); //∑(ai×Wi)(mod 11) //加权因子 var factor = [7, 9, 10, 5, 8, 4, 2, 1, 6, 3, 7, 9, 10, 5, 8, 4, 2]; //校验位 var parity = [1, 0, \"X\", 9, 8, 7, 6, 5, 4, 3, 2]; var sum = 0; var ai = 0; var wi = 0; for (var i = 0; i &lt; 17; i++) &#123; ai = code[i]; wi = factor[i]; sum += ai * wi; &#125; var last = parity[sum % 11]; if (parity[sum % 11] != code[17]) &#123; tip = \"身份证输入错误\"; pass = false; &#125; &#125; &#125; if (!pass) alert(tip) return pass; &#125;&#125; 10.银行卡校验12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364function luhmCheck()&#123; var lastNum = bankno.substr(bankno.length - 1, 1); //取出最后一位（与luhm进行比较） var first15Num = bankno.substr(0, bankno.length - 1); //前15或18位 var newArr = new Array(); for (var i = first15Num.length - 1; i &gt; -1; i--) &#123; //前15或18位倒序存进数组 newArr.push(first15Num.substr(i, 1)); &#125; var arrJiShu = new Array(); //奇数位*2的积 &lt;9 var arrJiShu2 = new Array(); //奇数位*2的积 &gt;9 var arrOuShu = new Array(); //偶数位数组 for (var j = 0; j &lt; newArr.length; j++) &#123; if ((j + 1) % 2 == 1) &#123; //奇数位 if (parseInt(newArr[j]) * 2 &lt; 9) arrJiShu.push(parseInt(newArr[j]) * 2); else arrJiShu2.push(parseInt(newArr[j]) * 2); &#125; else arrOuShu.push(newArr[j]); //偶数位 &#125; var jishu_child1 = new Array(); //奇数位*2 &gt;9 的分割之后的数组个位数 var jishu_child2 = new Array(); //奇数位*2 &gt;9 的分割之后的数组十位数 for (var h = 0; h &lt; arrJiShu2.length; h++) &#123; jishu_child1.push(parseInt(arrJiShu2[h]) % 10); jishu_child2.push(parseInt(arrJiShu2[h]) / 10); &#125; var sumJiShu = 0; //奇数位*2 &lt; 9 的数组之和 var sumOuShu = 0; //偶数位数组之和 var sumJiShuChild1 = 0; //奇数位*2 &gt;9 的分割之后的数组个位数之和 var sumJiShuChild2 = 0; //奇数位*2 &gt;9 的分割之后的数组十位数之和 var sumTotal = 0; for (var m = 0; m &lt; arrJiShu.length; m++) &#123; sumJiShu = sumJiShu + parseInt(arrJiShu[m]); &#125; for (var n = 0; n &lt; arrOuShu.length; n++) &#123; sumOuShu = sumOuShu + parseInt(arrOuShu[n]); &#125; for (var p = 0; p &lt; jishu_child1.length; p++) &#123; sumJiShuChild1 = sumJiShuChild1 + parseInt(jishu_child1[p]); sumJiShuChild2 = sumJiShuChild2 + parseInt(jishu_child2[p]); &#125; //计算总和 sumTotal = parseInt(sumJiShu) + parseInt(sumOuShu) + parseInt(sumJiShuChild1) + parseInt(sumJiShuChild2); //计算Luhm值 var k = parseInt(sumTotal) % 10 == 0 ? 10 : parseInt(sumTotal) % 10; var luhm = 10 - k; if (lastNum == luhm &amp;&amp; lastNum.length != 0) &#123; return true; &#125; else &#123; alert('银行卡号必须符合Luhm校验'); return false; &#125;&#125; 11.字符长度12345678910111213function getByteLen(val) &#123; var len = 0; for (var i = 0; i &lt; val.length; i++) &#123; var a = val.charAt(i); // console.log('a',a); if (a.match(/[^\\x00-\\xff]/ig) != null) &#123; len += 2; &#125; else &#123; len += 1; &#125; &#125; return len;&#125; 12.禁止页面鼠标右键和复制、粘贴事件12345678910111213document.oncontextmenu=function(e)&#123;return false;&#125;;document.oncopy=function(e)&#123;return false;&#125;;// 禁用Ctrl+C和Ctrl+V（所有浏览器均支持）$(document).keydown(function(e) &#123; if(e.ctrlKey &amp;&amp; (e.keyCode == 65 || e.keyCode == 67)) &#123; return false; &#125;&#125;);//禁止文字选中document.body.onselectstart = document.body.ondrag = function()&#123; return false;&#125; 13.计算周几了12345678910111213141516171819202122232425262728293031323334353637383940414243444546/** * Parse the time to string * @param &#123;(Object|string|number)&#125; time * @param &#123;string&#125; cFormat * @returns &#123;string&#125; */ function parseTime(time, cFormat) &#123; if (arguments.length === 0) &#123; return null &#125; const format = cFormat || '&#123;y&#125;-&#123;m&#125;-&#123;d&#125; &#123;h&#125;:&#123;i&#125;:&#123;s&#125;' let date if (typeof time === 'object') &#123; date = time &#125; else &#123; if ((typeof time === 'string') &amp;&amp; (/^[0-9]+$/.test(time))) &#123; time = parseInt(time) &#125; if ((typeof time === 'number') &amp;&amp; (time.toString().length === 10)) &#123; time = time * 1000 &#125; date = new Date(time) &#125; const formatObj = &#123; y: date.getFullYear(), m: date.getMonth() + 1, d: date.getDate(), h: date.getHours(), i: date.getMinutes(), s: date.getSeconds(), a: date.getDay() &#125; const time_str = format.replace(/&#123;(y|m|d|h|i|s|a)+&#125;/g, (result, key) =&gt; &#123; let value = formatObj[key] // Note: getDay() returns 0 on Sunday if (key === 'a') &#123; return ['日', '一', '二', '三', '四', '五', '六'][value ] &#125; if (result.length &gt; 0 &amp;&amp; value &lt; 10) &#123; value = '0' + value &#125; return value || 0 &#125;) return time_str&#125;`","tags":[]},{"title":"float列表两端对齐","date":"2018-07-28T10:12:01.000Z","path":"2018/07/28/float-list/","text":"我们在开发项目的时候，往往会碰到列表，从左至右依次排列的列表，循环的同时并要保证两端对齐，要是使两端对齐右一下方法： flex 盒子 justify-content: space-between方式 float浮动，设置父元素所有外边距负值 flex 方式这种方式使用最简单，只要设置父元素为display:flex,子元素会两端对齐：1234567891011121314151617181920&lt;div class=\"list\"&gt; &lt;div class=\"list-item\"&gt; 1 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 2 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 3 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 4 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 5 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 6 &lt;/div&gt; &lt;/div&gt; 1234567891011121314151617.list &#123; display: flex; justify-content: space-between; flex-wrap: wrap; width: 400px; padding: 5px; border: 1px solid green &#125; .list-item &#123; height: 100px; width: 100px; line-height: 100px; margin-bottom: 12px; text-align: center; border: 1px solid #e5e5e5; &#125; 这种方式很简单，但缺点就是有兼容性有兼容性的问题，而且当子元素只有两个的时候，就出现左右各一个，按照列表的循环应该是从左至右，现在左右各一个，不符合需求。这种方式舍弃。 float 列表这种方式设置自元素全部float:left向左浮动12345678910111213141516171819202122&lt;div class=\"wraper\"&gt; &lt;div class=\"list\"&gt; &lt;div class=\"list-item\"&gt; 1 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 2 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 3 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 4 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 5 &lt;/div&gt; &lt;div class=\"list-item\"&gt; 6 &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; 123456789101112131415161718192021222324252627282930.wraper &#123; margin: 0 auto; width: 400px; padding: 5px; box-sizing: border-box; border: 1px solid green; margin-bottom: 20px; &#125; .list &#123; overflow: hidden; margin-right: -40px; &#125; //清除浮动 .list::after &#123; content: \"\"; display: block; clear: both; &#125; .list-item &#123; height: 100px; width: 100px; float: left; margin-bottom: 12px; margin-right: 40px; line-height: 100px; text-align: center; border: 1px solid #e5e5e5; &#125; 父元素margin-right取自元素margin-right的负值就可以成功设置左右两端对齐，也不会出现flex那种问题","tags":[{"name":"float","slug":"float","permalink":"http://yoursite.com/tags/float/"}]},{"title":"vue高德地图","date":"2018-05-21T15:08:47.000Z","path":"2018/05/21/vue-map/","text":"在做基于LBS的应用中，时常会和地图打交道，最直接的解决方案，当然是去对应的地图官网找文档，然后一步步来玩。对于简单场景而言，体验应该还好，但对于一些状态多，变化频繁的复杂场景而言，不仅要时刻维护本地数据状态和地图状态同步，还要查找设置各种状态的地图API，实在是让人头疼的事情，这里我把我自己做过的经验分享一下，一来是自己做下笔记，二来是希望能给一些网友帮助。查看效果 - 项目目录结构 使用vue-cli创建的工程 - 引入高德地图资源在index.html页面加入资源： &lt;script src=&quot;http://webapi.amap.com/maps?v=1.4.5&amp;key=你的key&quot;&gt;&lt;/script&gt; 还没有创建过高德地图开发者账号的，这里有传送门 - 获取围栏列表查看高德地图地理围栏API文档，传送门通过查阅文档可知，查询围栏接口为：http://restapi.amap.com/v4/geofence/meta?key=用户key；这里建议开发者定义一个全局变量key,在后续的创建围栏、删除围栏都需要，这样方便以后更改。 获取数据结构为：123456789101112131415161718192021222324252627&#123; &quot;data&quot;: &#123; &quot;page_no&quot;: 1, &quot;page_size&quot;: 20, &quot;rs_list&quot;: [&#123; &quot;adcode&quot;: &quot;0&quot;, &quot;alert_condition&quot;: &quot;leave&quot;, &quot;center&quot;: &quot;112.996064,28.188747&quot;, &quot;create_time&quot;: &quot;2018-03-30 19:39:40&quot;, &quot;enable&quot;: true, &quot;fixed_date&quot;: &quot;&quot;, &quot;gid&quot;: &quot;9936a5cb-d629-4ea1-b736-4bb07704fa19&quot;, &quot;id&quot;: &quot;0&quot;, &quot;key&quot;: &quot;5a56c9f0200552fc3d02f25e387f9bdc&quot;, &quot;name&quot;: &quot;圆形围栏测试&quot;, &quot;points&quot;: &quot;&quot;, &quot;radius&quot;: 500, &quot;repeat&quot;: &quot;Mon,Tues,Wed,Thur,Fri,Sat,Sun&quot;, &quot;time&quot;: &quot;00:00,11:59;13:00,23:59&quot;, &quot;valid_time&quot;: &quot;2018-06-28&quot; &#125;], &quot;total_record&quot;: 3 &#125;, &quot;errcode&quot;: 0, &quot;errdetail&quot;: null, &quot;errmsg&quot;: &quot;OK&quot;&#125; 拿到数据后可以直接显示在页面当中：如图所示 - 创建围栏1、创建地图对象 再edit.vue中首先选定地图的div容器，再创建地图对象。 &lt;div id=&quot;container&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt; 在钩子函数mounted中创建地图对象。为什么要在mounted而不是在created呢？ created是在实列创建之后执行的函数，而mounted是在HTML加载完成之后执行的函数。地图这里适合这里创建地图对象。 2、设置marker点标注 设置围栏需要设置知道经度纬度，这就需要点击地图上任意位置，点击了还需要知道点击了哪些位置，所以需要设置marker点标注。 给地图绑定点击事件，绑定点击事件后，点击的时候回返回经度纬度，这那个便可以这只marker点。 在高德地图API文档中有绑定事件说明。原始写法中是这样的： 在这里我是做了这样的处理： //高德地图绑定点击事件 this.map.on(&quot;click&quot;, res =&gt; { //获取到经度纬度 let data = { Lng: res.lnglat.getLng(), lat: res.lnglat.getLat() }; }); 设置marker点： 高德地图API文档中设置marker 点写法为： marker = new AMap.Marker({ position: provinces[i].center.split(&apos;,&apos;), title: provinces[i].name }); marker.setMap(mapObj); 我在设置围栏点时候，设置两种类型，一种是圆形围栏，另外一种是多边形围栏。在设置圆形围栏点时候，你需要有一个更新marker点，以为圆形围栏是只有一个点，只需要设置半径大小。每次点击地图上点任意点都是更新marker点，也就是重新这只圆形围栏。 //第一次点击设置标记 var positionMark; postionMark = new AMap.Marker({ map: _this.map,//地图对象 icon: _this.markers[0].icon,//markers数组，储存marker点标注数据 position: [ _this.markers[0].position[0], _this.markers[0].position[1] ], offset: new AMap.Pixel(-12, -36) }); postionMark.setMap(_this.map); //更新点标注 //第二次更新标记，高德地图api方法 postionMark.setPosition([ _this.markers[0].position[0], _this.markers[0].position[1] ]); //更新点标记位置 具体代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292&lt;template&gt; &lt;div class=&quot;editmap-body&quot;&gt; &lt;mt-header title=&quot;电子围栏&quot;&gt; &lt;mt-button icon=&quot;back&quot; @click=&quot;goback&quot; slot=&quot;left&quot;&gt;&lt;/mt-button&gt; &lt;span slot=&quot;right&quot; @click=&quot;sheetVisible=true&quot;&gt;围栏类型&lt;/span&gt; &lt;/mt-header&gt; &lt;!-- 地图容器container --&gt; &lt;div id=&quot;container&quot; tabindex=&quot;0&quot;&gt;&lt;/div&gt; &lt;div class=&quot;drag-body&quot; v-show=&quot;drawType==0&quot;&gt; &lt;div class=&quot;drag&quot;&gt; &lt;mt-range v-model=&quot;radius&quot; :min=&quot;100&quot; :step=&quot;100&quot; :max=&quot;1500&quot;&gt; &lt;div slot=&quot;start&quot; style=&quot;margin-right: 5px;&quot;&gt;100&lt;/div&gt; &lt;div slot=&quot;end&quot; style=&quot;margin-left: 5px;&quot;&gt;150&lt;/div&gt; &lt;/mt-range&gt; &lt;p v-show=&quot;!isdraw&quot;&gt;当前圆形半径为：&#123;&#123;radius&#125;&#125;&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=&quot;footer-tip&quot;&gt; &lt;p v-if=&quot;drawType==1&quot;&gt;请在地图上点击三个以上的点组成一个闭合的多边形作为安全范围的区域&lt;/p&gt; &lt;p v-else&gt;请在地图上点击任意位置&lt;/p&gt; &lt;button class=&quot;btn-ok&quot; @click=&quot;goedit&quot;&gt;确定&lt;/button&gt; &lt;/div&gt; &lt;mt-actionsheet :actions=&quot;actions&quot; v-model=&quot;sheetVisible&quot;&gt;&lt;/mt-actionsheet&gt; &lt;transition name=&quot;slide&quot;&gt; &lt;router-view class=&quot;router-body&quot;&gt;&lt;/router-view&gt; &lt;/transition&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;var postionMark;var positionMarkPry;let circle, polygon, geolocation;export default &#123; data() &#123; return &#123; mapInfo: &#123;&#125;, sheetVisible: false, actions: [ &#123; name: &quot;圆形（默认）&quot;, method: this.drawClk, type: 0 &#125;, &#123; name: &quot;自定义形状&quot;, method: this.drawClk, type: 1 &#125; ], drawType: 0, markers: [], markerArray: [], isClik: true, isdraw: true, radius: 500, isfirstLoding: false &#125;; &#125;, created() &#123; if (this.$route.query.gid) &#123; this.getdata(); &#125; &#125;, mounted() &#123; let _this = this; //创建地图对象，并把对象复制给map。 this.map = new AMap.Map(&quot;container&quot;, &#123; //创建地图 resizeEnable: true, zoom: 14 &#125;); if (!this.$route.query.gid) &#123; //如果是新建那么就获取用户所在位置 this.map.plugin(&quot;AMap.Geolocation&quot;, function() &#123; geolocation = new AMap.Geolocation(&#123; enableHighAccuracy: true, //是否使用高精度定位，默认:true timeout: 10000, //超过10秒后停止定位，默认：无穷大 buttonOffset: new AMap.Pixel(10, 20), //定位按钮与设置的停靠位置的偏移量，默认：Pixel(10, 20) zoomToAccuracy: true, //定位成功后调整地图视野范围使定位位置及精度范围视野内可见，默认：false buttonPosition: &quot;RB&quot; &#125;); _this.map.addControl(geolocation); geolocation.getCurrentPosition(); &#125;); &#125; postionMark = this.map; //高德地图绑定点击事件 this.map.on(&quot;click&quot;, res =&gt; &#123; let data = &#123; Lng: res.lnglat.getLng(), lat: res.lnglat.getLat() &#125;; this.mapClk(data); &#125;); &#125;, methods: &#123; getdata() &#123; this.isfirstLoding = true; this.$http .get(&quot;http://restapi.amap.com/v4/geofence/meta&quot;, &#123; params: &#123; key: this.mapKey, gid: this.$route.query.gid, page_no: 1, page_size: 20 &#125; &#125;) .then(res =&gt; &#123; this.mapInfo = res.data.data.rs_list[0]; let data = this.mapInfo.center.split(&quot;,&quot;); this.map.setCenter([data[0], data[1]]); //设置地图中心点 if (this.mapInfo.points==&apos;&apos;) &#123; let data = this.mapInfo.center.split(&quot;,&quot;); this.mapClk(&#123; Lng: data[0], lat: data[1] &#125;); this.radius = this.mapInfo.radius; //圆形半径 &#125; else &#123;//多边形 let data = this.mapInfo.points.split(&quot;;&quot;); this.drawType = 1; data.forEach((ary, index) =&gt; &#123; this.markers.push(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [ary.split(&quot;,&quot;)[0], ary.split(&quot;,&quot;)[1]] &#125;); if (index == data.length - 1) &#123; this.setting(); this.drawSt(); this.isfirstLoding = false; &#125; &#125;); &#125; &#125;) .catch(err =&gt; &#123; this.toast(&quot;查询失败&quot;); &#125;); &#125;, mapClk(res) &#123; if (this.drawType == 0) &#123; this.markers = [ &#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [res.Lng, res.lat] &#125; ]; //如果是圆形类型 this.setting(); this.drawSt(); &#125; else &#123; //自定义形状 this.markers.push(&#123; icon: &quot;http://webapi.amap.com/theme/v1.3/markers/n/mark_b.png&quot;, position: [res.Lng, res.lat] &#125;); this.setting(); if (this.markers.length &gt; 3 || this.markers.length == 3) &#123; this.drawSt(); &#125; &#125; &#125;, setting() &#123; //设置标记点 let _this = this; if (this.drawType == 0) &#123; if (this.isClik) &#123; //第一次点击设置标记 postionMark = new AMap.Marker(&#123; map: _this.map, icon: _this.markers[0].icon, position: [ _this.markers[0].position[0], _this.markers[0].position[1] ], offset: new AMap.Pixel(-12, -36) &#125;); postionMark.setMap(_this.map); this.isClik = false; &#125; else &#123; //第二次更新标记 postionMark.setPosition([ _this.markers[0].position[0], _this.markers[0].position[1] ]); //更新点标记位置 &#125; &#125; else &#123; //多边形标记 this.markers.forEach(function(marker) &#123; positionMarkPry = new AMap.Marker(&#123; map: _this.map, icon: marker.icon, position: [marker.position[0], marker.position[1]], offset: new AMap.Pixel(-12, -36) &#125;); _this.markerArray.push(positionMarkPry); positionMarkPry.setMap(_this.map); &#125;); &#125; &#125;, drawSt() &#123; //画围栏事件 let _this = this; //画出围栏 if (this.drawType == 0) &#123; //圆形类型 if (this.isdraw) &#123; //第一个设置圆形 circle = new AMap.Circle(&#123; center: new AMap.LngLat( _this.markers[0].position[0], _this.markers[0].position[1] ), // 圆心位置 radius: _this.radius, //半径 strokeColor: &quot;#F33&quot;, //线颜色 strokeOpacity: 1, //线透明度 strokeWeight: 3, //线粗细度 fillColor: &quot;#ee2200&quot;, //填充颜色 fillOpacity: 0.35 //填充透明度 &#125;); circle.setMap(this.map); this.isdraw = false; &#125; else &#123; //更新圆形中心位置 circle.setCenter([ this.markers[0].position[0], this.markers[0].position[1] ]); &#125; &#125; else &#123; //自定义类型 let polygonArr = new Array(); //多边形覆盖物节点坐标数组 this.markers.forEach(function(marker) &#123; polygonArr.push([marker.position[0], marker.position[1]]); &#125;); polygon = new AMap.Polygon(&#123; path: polygonArr, //设置多边形边界路径 strokeColor: &quot;#FF33FF&quot;, //线颜色 strokeOpacity: 0.2, //线透明度 strokeWeight: 3, //线宽 fillColor: &quot;#1791fc&quot;, //填充色 fillOpacity: 0.35 //填充透明度 &#125;); polygon.setMap(this.map); &#125; &#125;, drawClk(val) &#123; //选择围栏类型 this.drawType = val.type; &#125;, goback() &#123; //返回上一页 this.$router.go(-1); &#125;, goedit() &#123; let datajson; if (this.markers.length == 0) &#123; this.toast(&quot;请先设置围栏&quot;); return false; &#125; if (this.drawType == 0) &#123; datajson = &#123; type: this.drawType, data: this.markers, radius: this.radius &#125;; &#125; else &#123; datajson = &#123; type: this.drawType, data: this.markers, radius: &quot;&quot; &#125;; &#125; this.$store.commit(&quot;setMap&quot;, datajson); //把数据存入仓库当中 this.$router.push(&#123; path: &quot;/editMap/mapInfo_edit&quot;, query: &#123; gid: this.$route.query.gid, name: this.mapInfo.name,id:this.$route.query.id&#125; &#125;); &#125; &#125;, watch: &#123; radius(val) &#123; //监听改变拖动value的值 circle.setRadius(val); &#125;, drawType(val) &#123; /*** * 当this.drawType为0时切换为了圆形围栏，那么需要置空多边形。设置isClick为true,isdraw为true * */ console.log(this.isfirstLoding) if (!this.isfirstLoding) &#123; console.log(&apos;变化&apos;) //判断是否为编辑围栏，如果为编辑围栏那么初次进入页面注销watch事件 if (this.markers.length &gt; 0) &#123; if (val == 0) &#123; this.map.remove(this.markerArray); polygon.setMap(null); this.isClik = true; this.isdraw = true; &#125; else &#123; postionMark.setMap(null); circle.setMap(null); &#125; this.markers = []; &#125; &#125; &#125; &#125;&#125;;&lt;/script&gt; 以上代码就是具体点设置地理围栏点方法，最重要点是查看API文档，高德地图里每个参数都是有写，仔细查看都能找到具体的方法。文档就写到这里，如果有什么问题可以随时在github上留言。把自己折腾的东西写出来是为了以后工作中快速找到问题点，再一个就是给自己给同样遇到问题的网友提供帮助。欢迎吐槽。。。","tags":[{"name":"vue 高的地图","slug":"vue-高的地图","permalink":"http://yoursite.com/tags/vue-高的地图/"}]},{"title":"讲一讲如何使用DataTable","date":"2017-11-22T13:54:00.000Z","path":"2017/11/22/datatable/","text":"可能有人说现在第是使用前端三大框架来做项目，利用数据绑定来实现表格的操作极其方便快捷。但是没有接触过这三大框架的人多多少少有用过jq dataTable这个插件。我在进入前端这个方向的时候我直接接触了Angularjs了，利用双向数据绑定来做表格特别的方便快捷，后来换了公司，因为需要维护项目所以才接触这个jq插件。总得来说阅读过插件的API还是觉得挺方便的，毕竟别人都封装好了方法。但是中文网上的实例实在是少了，不够详细，想我等菜鸟只能是google了。如今对这个表格还算是挺熟悉的，所以记录下来，以便各位网友遇到问题是能够作为参考，也有不对之处敬请指出更正。 dataTablejQuery 的插件 dataTables 是一个优秀的表格插件，提供了针对表格的排序、浏览器分页、服务器分页、筛选、格式化等功能。dataTables 的网站上也提供了大量的演示和详细的文档进行说明，为了方便学习使用，这里一步一步进行说明。首先，需要到 dataTables(中文网点这里) 的网站 下载脚本库。 使用方法直接上代码： 引入css和js文件 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;link href=\"datatables/datatables.min.css\" rel=\"stylesheet\"&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap/datatables.bootstrap.css\"&gt; &lt;title&gt;datatable&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table class=\"table table-striped table-bordered table-hover table-checkable order-column\" id=\"News_article_table\"&gt; &lt;/table&gt; &lt;script src=\"jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"datatables/datatables.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/bootstrap/datatables.bootstrap.js\"&gt;&lt;/script&gt; &lt;script src=\"/controller/dataTatbalCtrl\"&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; js文件（dataTatbalCtrl.js）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var News_article_table = $('#News_article_table').dataTable(&#123; ajax: &#123; url: 'url', type: 'get', data: null, dataType: 'json', scriptCharset: 'utf-8', async: false, dataSrc: function (result) &#123; localStorage.all = JSON.stringify(result.data); return result.data; &#125; &#125;, \"language\": &#123; \"aria\": &#123; \"sortAscending\": \": 升序排列\", \"sortDescending\": \": 降序排列\" &#125;, \"emptyTable\": \"没有数据显示\", \"info\": \"显示_START_ 到 _END_ 条/ 共_TOTAL_ 条\", \"infoEmpty\": \"没有搜索到结果\", \"infoFiltered\": \"\", \"lengthMenu\": \"&lt;span class='tab-page-show'&gt;显示&lt;/span&gt; _MENU_ &lt;span class='tab-page-show'&gt;条&lt;/span&gt;\", \"search\": \"&lt;span class='tab-search'&gt;查询&lt;/span&gt;\", \"zeroRecords\": \"没有匹配到数据\", \"paginate\": &#123; \"previous\": \"上页\", \"next\": \"下页\", \"last\": \"末页\", \"first\": \"首页\" &#125; &#125;, bStateSave: true, // 保存状态 - 在页面重新加载的时候恢复状态（页码等内容） lengthMenu: [ [5, 8, 10, 15, -1], [5, 8, 10, 15, \"全部\"] // change per page values here ], // set the initial value pageLength: 10, pagingType: \"bootstrap_full_number\", //去掉默认的排序三角形图标 order: [], columns: [ &#123; data: null, title: '&lt;label class=\"mt-checkbox mt-checkbox-single mt-checkbox-outline\"&gt;' + '&lt;input type=\"checkbox\" class=\"group-checkable\" data-set=\"#News_article_table .checkboxes\" /&gt;' + '&lt;span&gt;&lt;/span&gt;' + '&lt;/label&gt;', width: \"5%\", orderable: false //配合order:[] 屏蔽排序和三角图标 &#125;, &#123; data: \"null\",//服务器返回的 字段名，如果需要进行数据处理可以填写为null, title: \"基本信息\",//表头信息 width: \"25%\",//列宽 render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125; ], columnDefs: [&#123; //指定第第一列（check框） targets: 0, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;, &#123; // 指定第最后一列 targets: 7, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;] &#125;); 配置参数可看api文档，讲的也很详细。以上的是实现的是前端实现分页操作，服务器会把全部数据给你。一次性查找所需的所有数据（但对于若查找的数据有上万条效率太低）所以用服务器端动态分页：一次访问几条，多次访问后台数据； 服务器分页配置如果需要进行服务器分页的需要把serverSide设置为true,在上列的没有写该参数，默认情况时false，所以需要写入该参数；这里建议阅读http://www.datatables.club/manual/server-side.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var News_article_table = $('#News_article_table').dataTable(&#123; \"bProcessing\":false,//是否显示处理状态(排序的时候，数据很多耗费时间长的话，也会显示这个) \"sAjaxSource\":'news/lists',//接口请求地址 \"serverSide\":true,//开启服务器模式 \"fnServerData\":function(sSource, aoData, fnCallback)&#123; var page = aoData[3].value/aoData[4].value; // console.log(page); var currenPage= page==Infinity?1:parseInt(page)+1; aoData.push(&#123;name:'currenPage',value:currenPage&#125;);//我个人添加这个当前页 $.ajax(&#123; url: sSource, type: 'get', data: aoData, dataType: 'json', scriptCharset: 'utf-8', async: false, success:function(resp)&#123; fnCallback(resp); &#125; &#125;); &#125;, \"language\": &#123; \"aria\": &#123; \"sortAscending\": \": 升序排列\", \"sortDescending\": \": 降序排列\" &#125;, \"emptyTable\": \"没有数据显示\", \"info\": \"显示_START_ 到 _END_ 条/ 共_TOTAL_ 条\", \"infoEmpty\": \"没有搜索到结果\", \"infoFiltered\": \"\", \"lengthMenu\": \"&lt;span class='tab-page-show'&gt;显示&lt;/span&gt; _MENU_ &lt;span class='tab-page-show'&gt;条&lt;/span&gt;\", \"search\": \"&lt;span class='tab-search'&gt;查询&lt;/span&gt;\", \"zeroRecords\": \"没有匹配到数据\", \"paginate\": &#123; \"previous\": \"上页\", \"next\": \"下页\", \"last\": \"末页\", \"first\": \"首页\" &#125; &#125;, bStateSave: false, // 保存状态 - 在页面重新加载的时候恢复状态（页码等内容） lengthMenu: [ [5, 8, 10, 15, -1], [5, 8, 10, 15, \"全部\"] // change per page values here ], // set the initial value pageLength: 10, pagingType: \"bootstrap_full_number\", //去掉默认的排序三角形图标 order: [], columns: [ &#123; data: null, title: '&lt;label class=\"mt-checkbox mt-checkbox-single mt-checkbox-outline\"&gt;' + '&lt;input type=\"checkbox\" class=\"group-checkable\" data-set=\"#News_article_table .checkboxes\" /&gt;' + '&lt;span&gt;&lt;/span&gt;' + '&lt;/label&gt;', width: \"5%\", orderable: false //配合order:[] 屏蔽排序和三角图标 &#125;, &#123; data: \"null\",//服务器返回的 字段名，如果需要进行数据处理可以填写为null, title: \"基本信息\",//表头信息 width: \"25%\",//列宽 render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125; ], columnDefs: [&#123; //指定第第一列（check框） targets: 0, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;, &#123; // 指定第最后一列 targets: 7, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;]&#125;); 开启服务器处理模式，这时我们对表格的每次操作，datatable都会帮我们向服务器发起请求获取数据，默认是用GET方式传递参数，所以我们下面加上了”fnServerData”，这样可以修改参数传递的方式为POST，那么到底给服务端发送的”aoData”是个什么鬼呢，别急，我们直接从Servlet取出来看看就知道了我们在浏览器打开页面并打印aoData 12345678910111213141516171819202122232425 [&#123;“name”:”sEcho”,”value”:1&#125;, &#123;“name”:”iColumns”,”value”:3&#125;, &#123;“name”:”sColumns”,”value”:”,,”&#125;, &#123;“name”:”iDisplayStart”,”value”:0&#125;, &#123;“name”:”iDisplayLength”,”value”:10&#125;, &#123;“name”:”mDataProp_0”,”value”:”id”&#125;, &#123;“name”:”sSearch_0”,”value”:”“&#125;, &#123;“name”:”bRegex_0”,”value”:false&#125;, &#123;“name”:”bSearchable_0”,”value”:true&#125;, &#123;“name”:”bSortable_0”,”value”:true&#125;, &#123;“name”:”mDataProp_1”,”value”:”name”&#125;, &#123;“name”:”sSearch_1”,”value”:”“&#125;, &#123;“name”:”bRegex_1”,”value”:false&#125;, &#123;“name”:”bSearchable_1”,”value”:true&#125;, &#123;“name”:”bSortable_1”,”value”:true&#125;, &#123;“name”:”mDataProp_2”,”value”:”age”&#125;, &#123;“name”:”sSearch_2”,”value”:”“&#125;, &#123;“name”:”bRegex_2”,”value”:false&#125;, &#123;“name”:”bSearchable_2”,”value”:true&#125;, &#123;“name”:”bSortable_2”,”value”:true&#125;, &#123;“name”:”sSearch”,”value”:”“&#125;, &#123;“name”:”bRegex”,”value”:false&#125;, &#123;“name”:”iSortCol_0”,”value”:0&#125;, &#123;“name”:”sSortDir_0”,”value”:”asc”&#125;, &#123;“name”:”iSortingCols”,”value”:1&#125;] 刚刚开始看到这些数据我真的有点乱，一个分页查询看到有这么多参数sEcho：客户端发送请求同时发送过来的一个标识，虽然有什么卵用不知道，不过我们服务端返回的数据中必须带有这个标识，哦，官网的文档里说，服务端取出标识最好转一下转成int，防止XXS攻击（懵逼，暂且不管，我们只知道需要这个就行）iColumns：列数iDisplayStart：起始索引iDisplayLength：显示的行数{“name”:”mDataProp_0”,”value”:”id”},{“name”:”sSearch_0”,”value”:”“},{“name”:”bRegex_0”,”value”:false},{“name”:”bSearchable_0”,”value”:true},{“name”:”bSortable_0”,”value”:true}每一列的参数设置，_0即是第一列，这个我们不管，到下面也是提取列名而已sSearch：全局搜索字段iSortCol_0：被排序的列sSortDir_0：排序方式； 服务端必须返回的数据格式如下：123456&#123; draw:1,//必须 ，Datatables发送的draw是多少那么服务器就返回多少。 这里注意，作者出于安全的考虑，强烈要求把这个转换为整形，即数字后再返回，而不是纯粹的接受然后返回，这是 为了防止跨站脚本（XSS）攻击。也就上面的sEcho字段给了服务端多少，服务端就返回多少 recordsTotal:25,//即没有过滤的记录数（数据库里总共记录数） recordsFiltered:25, // 过滤后的记录数（如果有接收到前台的过滤条件，则返回的是过滤后的记录数） data:[]&#125; 至此服务端分页完成。以上是根据中文网提供的api文档以及网友提供的方法总结出来的，总体是还是很乱，因为中文网api所提供的参数与网友所提供的api参数并不一致，但是在我这里却都可以。也有可能是文件版本的问题。如果有其它疑问可以给我留言。","tags":[{"name":"jqdatatable","slug":"jqdatatable","permalink":"http://yoursite.com/tags/jqdatatable/"}]},{"title":"hexo Yilia 主题如何添加相册功能","date":"2017-11-05T14:27:35.000Z","path":"2017/11/05/2017-11-5相册教程/","text":"如果你拥有hexo搭建的博客，然后使用也是Yilia主题的应该知道Yilia主题会有一个相册的。我也是使用的这一套主题，然后也很想搞一个相册，在Yilia主题的作者 Litten的github上留言问了如何实现这一个功能，作者也没有详细说明，我这里根据网友提供的方法来实现的。这里贴一下链接吧：点击这里可能更加详细。自己整理了一下思路： 在主页上必须有一个可供点击的相册链接 要用 hexo 生成一个 photos.html 文件 photos.html 中的图片数据来源?因为这是一个静态页面所有要有一个 json 文件，其实就是ajax请求json文件来渲染的 json 文件中有含有信息,图片的文件名. 图片要有一个完整的路径,把图片放到哪呢?七牛的图床,github 的空间,自己的服务器都可以. .怎么上传呢?大量图片当然写脚本传了.不会写咋办?很多人都写好了,改改就是了,脚本也有很多个版本.多数用 nodeJS写的,hexo 就用的 nodeJS.Python也是很不错的选择. 准备两套图片，一套大图(原图)，一套小图（缩率） 通过hexo d来生成相册页面 1. 提供一个可点击的链接。 1.进入你的博客目录下通过命令 hexo new page “photos”就会在source目录下生成photos这个文件夹 2.配置 Yilia 主题让其显示出来. yourBlog/themes/yilia/_config.yml文件中这样设置 12主页: /相册: photos 2. 如何生成一个photos.html这个文件 1.这里我也不知道具体如何生成，具体的代码我没有去看，因为我认为这仅仅是一个工具。所以我直接下载了作者的文件。下载地址，你也可以下载我的备份文件 2.这里就是放相册资源的目录，我是模仿作者的目录来的，具体的文件中怎么写可以直接参考Yilia主题的作者，我是直接拷贝下来的。说明一下:data.json这个文件开始是不存在。ejs 文件是以后要hexo 文件渲染的文件.assets 目录是放默认图片的也要有.3.index.ejs文件可以修改也可以不修改，作者里是把评论的功能去掉了。而我把comments设置了true。4.修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(七牛的, github的路径).![此处输入图片的描述][4]上面的代码只需要修改路劲就可以了。我在这里遇到一个坑，我下载了作者的代码，只修改了minSrc 和src这个路劲，但是最后发现缩略图没法显示，我在浏览器审查的时候发现，figure标签下的img标签的src路劲的地址不对，所我做了更改，直接把修改了minSrc. 3. 生成json文件 这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,所以你需要在你的博客目录下准备如下图所示的文件 ![此处输入图片的描述][5]你把图片都放在这个文件之后执行python脚本后就会生成json文件的。然后把图片再上传的七牛或者 github 上每次更新图片都要执行脚本重新生成 json 文件.这个json 文件会出现在yourBlog/source/photos/data.json图片如何命名，然后显示日期，这里可以看这位博主的点击查看 4. 处理图片我用的别人写好的脚本,看他写得已经很全了,我也懒得再写了.改改就好了.[脚本下载地址][6].py 文件就是 Python 的脚本.脚本的内容我就不讲了，因为我也不懂python语法，开始我下载下来然后执行的时候报错，折腾了很久才搞定的，要修改的地方就是： 173行的git_operation()方法，这个方法是把图片上传至github的，然如果你图片确实是放在github上，那就没必要注释掉。而我这里是放在七牛上的，所以用不到该方法。 大概131行这里，我执行脚本的时候报错了，源码上写的是../lawlite19.github.io/source/photos/data.json是对应到作者的博客的路径，这里根据需要改成自己博客的路径。而我这里更改成了本地 source/phontos。最后就是执行脚本的功夫了 5. 可能出现的问题（我是出现过的） 在命令行执行python too.py 命令的时候出现no module named PIL错误百度后知道出现这错误的原因是: PIL 模块找不到,PIL 模块已经过时了.解决方案: 安装 pip install pillow（cmd执行该命令就好了）关于Python如何安装，建议谷歌或者百度。 6. 如何执行 cmd切换到你的博客目录下，然后执行 python tool.py(处理图片,上传图片,生成 json 文件)hexo clean (清理之前的 HTML 等)hexo g (生成 HTML 文件)hexo s (看看效果如何)最后部署到你的博客上.网上大致文章都是这么的写,找到一个差不多就开始实践吧,如果你看我的去实践遇到问题可以找我,我只要有时间定会回复你.如果遇见更多的坑欢迎补充(github提问,博客评论, QQ 加好友都可以哦)✌️","tags":[]},{"title":"vue集成百度Ueditor富文本编辑器","date":"2017-07-25T13:54:00.000Z","path":"2017/07/25/vue-ueditor/","text":"有使用vue来开发项目可能使用一下较为简单的富文本编辑器，功能不是很全面。如果涉及到自媒体运营类的系统Ueditor再适合不过了。网上的富文本编辑器众多，比如：wangEditor 、Simditor 、tinymce等。富文本编辑器设计到的知识面特别广，如果你想自己做简单的nname也可以、利用HTML5中的属性contenteditable，把他放在div上设为true时便可以编辑，但是坑也很多。你可以点击为什么说富文本编辑器是天坑这里来看看大神们的回答。这里只讲讲在vue项目中如何集成ueditor，如果你有这个需求希望可以帮助到你效果图如下： 1、 首先使用vue-cli脚手架建立一个vue工程，然后去ueditor官网下载源码。地址：http://ueditor.baidu.com/website/ 。把项目复制到vue项目的static文件下。目的是让服务可以访问到里面的文件，打开UEditor目录文件，我这里下载的是nodejs版本的； 项目结构如下： 2、然后再main.js中引入js文件 import &apos;../static/ueditor/ueditor.config&apos; import &apos;../static/ueditor/ueditor.all&apos; import &apos;../static/ueditor/lang/zh-cn/zh-cn&apos; import &apos;../static/ueditor/ueditor.parse.min&apos; 3、创建组件。在components文件里面创建.vue文件，命名随便你。我这里是命名为ueditor.vue。 &lt;template&gt; &lt;el-row&gt; &lt;el-col :span=&quot;18&quot; :offset=&quot;3&quot;&gt; &lt;div class=gird-content&gt; &lt;div id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:1024px;height:500px;&quot;&gt;&lt;/div&gt; &lt;el-button type=&quot;info&quot; @click=&quot;getUedtorContent&quot;&gt;保存&lt;/el-button&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; import ElButton from &quot;../../node_modules/element-ui/packages/button/src/button&quot;; export default{ components: {ElButton}, name: &apos;addnew&apos;, data () { return { input: &apos;&apos;, editor: null } }, mounted () { this.editor =UE.getEditor(&apos;editor&apos;, { UEDITOR_HOME_URL: &apos;/static/ueditor/&apos;,//配置资源路径 toolbars: [ [ &apos;anchor&apos;, //锚点 &apos;undo&apos;, //撤销 &apos;redo&apos;, //重做 &apos;bold&apos;, //加粗 &apos;indent&apos;, //首行缩进 &apos;snapscreen&apos;, //截图 &apos;italic&apos;, //斜体 &apos;underline&apos;, //下划线 &apos;strikethrough&apos;, //删除线 &apos;subscript&apos;, //下标 &apos;fontborder&apos;, //字符边框 &apos;superscript&apos;, //上标 &apos;formatmatch&apos;, //格式刷 &apos;source&apos;, //源代码 &apos;blockquote&apos;, //引用 &apos;pasteplain&apos;, //纯文本粘贴模式 &apos;selectall&apos;, //全选 &apos;print&apos;, //打印 &apos;preview&apos;, //预览 &apos;horizontal&apos;, //分隔线 &apos;removeformat&apos;, //清除格式 &apos;time&apos;, //时间 &apos;date&apos;, //日期 &apos;unlink&apos;, //取消链接 &apos;insertrow&apos;, //前插入行 &apos;insertcol&apos;, //前插入列 &apos;mergeright&apos;, //右合并单元格 &apos;mergedown&apos;, //下合并单元格 &apos;deleterow&apos;, //删除行 &apos;deletecol&apos;, //删除列 &apos;splittorows&apos;, //拆分成行 &apos;splittocols&apos;, //拆分成列 &apos;splittocells&apos;, //完全拆分单元格 &apos;deletecaption&apos;, //删除表格标题 &apos;inserttitle&apos;, //插入标题 &apos;mergecells&apos;, //合并多个单元格 &apos;deletetable&apos;, //删除表格 &apos;cleardoc&apos;, //清空文档 &apos;insertparagraphbeforetable&apos;, //&quot;表格前插入行&quot; &apos;insertcode&apos;, //代码语言 &apos;fontfamily&apos;, //字体 &apos;fontsize&apos;, //字号 &apos;paragraph&apos;, //段落格式 &apos;simpleupload&apos;, //单图上传 &apos;insertimage&apos;, //多图上传 &apos;edittable&apos;, //表格属性 &apos;edittd&apos;, //单元格属性 &apos;link&apos;, //超链接 &apos;emotion&apos;, //表情 &apos;spechars&apos;, //特殊字符 &apos;searchreplace&apos;, //查询替换 &apos;map&apos;, //Baidu地图 &apos;gmap&apos;, //Google地图 &apos;insertvideo&apos;, //视频 &apos;help&apos;, //帮助 &apos;justifyleft&apos;, //居左对齐 &apos;justifyright&apos;, //居右对齐 &apos;justifycenter&apos;, //居中对齐 &apos;justifyjustify&apos;, //两端对齐 &apos;forecolor&apos;, //字体颜色 &apos;backcolor&apos;, //背景色 &apos;insertorderedlist&apos;, //有序列表 &apos;insertunorderedlist&apos;, //无序列表 &apos;fullscreen&apos;, //全屏 &apos;directionalityltr&apos;, //从左向右输入 &apos;directionalityrtl&apos;, //从右向左输入 &apos;rowspacingtop&apos;, //段前距 &apos;rowspacingbottom&apos;, //段后距 &apos;pagebreak&apos;, //分页 &apos;insertframe&apos;, //插入Iframe &apos;imagenone&apos;, //默认 &apos;imageleft&apos;, //左浮动 &apos;imageright&apos;, //右浮动 &apos;attachment&apos;, //附件 &apos;imagecenter&apos;, //居中 &apos;wordimage&apos;, //图片转存 &apos;lineheight&apos;, //行间距 &apos;edittip &apos;, //编辑提示 &apos;customstyle&apos;, //自定义标题 &apos;autotypeset&apos;, //自动排版 &apos;webapp&apos;, //百度应用 &apos;touppercase&apos;, //字母大写 &apos;tolowercase&apos;, //字母小写 &apos;background&apos;, //背景 &apos;template&apos;, //模板 &apos;scrawl&apos;, //涂鸦 &apos;music&apos;, //音乐 &apos;inserttable&apos;, //插入表格 &apos;drafts&apos;, // 从草稿箱加载 &apos;charts&apos;, // 图表 ] ], autoHeightEnabled: true, autoFloatEnabled: true, minFrameHeight: 500, }); }, destroyed(){ this.editor.destroy(); }, methods:{ getUedtorContent: function () { console.log(this.editor.getContent()); } } } &lt;/script&gt; 4、在你想要显示第view中引入该组件即可。 关于上传地址配置需要在ueditot.config.js文件里面进行配置。这里也需要后端配置，具体实现可以在uedtor文档上进行查看。贴上我这里的代码：ueditot.config.js中：serverUrl: “/ue” // 服务器统一请求接口路径后端接口： app.use(&quot;/ue&quot;, ueditor(path.join(__dirname,&apos;/public&apos;), function (req, res, next) { //客户端上传文件设置 var imgDir = &apos;/img/ueditor/&apos;; var ActionType = req.query.action; if (ActionType === &apos;uploadimage&apos; || ActionType === &apos;uploadfile&apos; || ActionType === &apos;uploadvideo&apos;) { var file_url = imgDir;//默认图片上传地址 /*其他上传格式的地址*/ if (ActionType === &apos;uploadfile&apos;) { file_url = &apos;/file/ueditor/&apos;; //附件 } if (ActionType === &apos;uploadvideo&apos;) { file_url = &apos;/video/ueditor/&apos;; //视频 } res.ue_up(file_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;); } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;) { var dir_url = imgDir; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { // console.log(&apos;config.json&apos;) res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/static/ueditor/nodejs/config.json&apos;); } })); 需要注意的是资源路径容易搞错。使用相对路径即可 以上都是个人在开发过程中遇到的问题然后根据网友提供的方法再自己整理出来，然后记录下来的。希望对大家有所帮忙。","tags":[]},{"title":"简单的讲一讲es6常用的特性","date":"2017-07-24T16:28:00.000Z","path":"2017/07/25/es6_aticle/","text":"最近一段时间基本上忙着自己的事情，忙着学习vuex、webpack、es6还有要弄一个vue+nodejs+mysql搞一个简单点开源项目，也在研究微信小程序。正经的写博客也是头一次，利用这个时候写一篇博客试试，讲讲我学过后的es6一些知识。 什么是ES6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。上个周在segmentfault社区里面看到推送的一周周刊里就说道es7已经在六月底就正式发布了，我看这是一年一个版本的节奏，只能说前端的技术更新太快。所以作为前端开发者的你还不关注新的技术那就out了，不会es6的基础用法都不太算是一名前端开发者了。 什么是BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看 ####let 和 const 命令在es6之前我们都是使用var来声明一个变量，在es6的时候新增了let、const命令，虽然这两个变量与var类似，但是实际运用中他俩都有各自的特殊用途。首先来看下面这个例子：1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用var声明的变量b在代码块之外还能得到1，但是用let定义的变量b在代码块之外却是报错。这是因为let声明的变量只在它所在的代码块有效let命令在for循环场景里面最适合不过了1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码使用var来声明那就不一样了1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require(&apos;moment&apos;) 变量结构（基础用法）ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。除了数组可以解构外还有对象解构，反正我觉得很方便（滑稽表情）123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 模板字符串（template string）这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，经常出现的场景就是使用jq append()的时候回写一大推，一不小心还可能写错，所以之前我们通常会引用一些模板工具库，比如mustache等等。传统的JavaScript语言，输出模板通常是这样写的。123456$(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; + &apos;items in your basket, &apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos;); ES6引入了模板字符串12345$(&apos;#result&apos;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。可能你在一些网友写的代码中看到，如果你看到了说明就是es的写法,这es6最常用的特效了。1var f = v =&gt; v; 等同于下面这种：123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; ####没有局部this的绑定和一般的函数不同，箭头函数不会绑定this。 或则说箭头函数不会改变this本来的绑定。我们用一个例子来说明：123456789101112function Counter() &#123; this.num = 0; this.timer = setInterval(function add() &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// NaN// NaN// NaN// ... 使用了关键字new构造，Count()函数中的this绑定到一个新的对象，并且赋值给a你会发现，每隔一秒都会有一个NaN打印出来，而不是累加的数字我们来尝试理解为什么出错：首先函数setInterval没有被某个声明的对象调用，也没有使用new关键字，再之没有使用bind, call和apply。setInterval只是一个普通的函数。实际上setInterval里面的this绑定到全局对象的。我们可以通过将this打印出来验证这一点：12345678910function Counter() &#123; this.num = 0;this.timer = setInterval(function add() &#123; console.log(this); &#125;, 1000);&#125;var b = new Counter();//Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; 当我们用箭头函数就能解决这个问题12345678910111213function Counter() &#123; this.num = 0; this.timer = setInterval(() =&gt; &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// 1// 2// 3// ... 摘一下阮老师的教程：箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 set函数ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。1234567891011// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]//列二const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 以前我们取出数组里面的重复值会用到遍历，然后用indexOf方法去做: 123456789var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;] var arr2 = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr2.indexOf(arr[i])&lt;0)&#123; arr2.push(arr[i]); &#125; &#125; arr2.sort(); console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 如果用Set()来去除数组里面的重复值那就更加简单123var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;]var arr2 = [...new Set(arr)]console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 更多关于Set函数的属性和方法可以看阮老师的教程。再一次感谢您花费时间阅读这份没水平的文章，尝试第一次写好一点的博客，最近学习的es6，我觉得很多新特性在日常开发当中我们都可以用上，比如我现在很喜欢的前端框架Vue，FaceBook的react 都在使用es6，所以推荐大家使用起来，加快我们的开发效率。 欢迎吐槽。。。 2016 年 07月 25日","tags":[]},{"title":"想要提升移动网页的加载速度？你可以Get这些技能","date":"2017-06-19T13:41:03.000Z","path":"2017/06/19/new-article/","text":"在这个信息爆炸的时代，使用移动终端获取新鲜信息已经是大势所趋，但是移动网页浏览速度还有巨大的提升空间。据 Strangeloop Networks 统计，在同样的网络条件下，使用移动端访问相同网页平均会比 PC 端慢 40%！ 然而另一方面，用户对网速的要求却步步紧逼。Akamai 的研究表明，网页响应时间可容忍的阀值是 2 秒，一旦超过 3 秒，会有 40% 的用户放弃浏览页面。简而言之，作为内容服务商的你，可能因为移动网页的加载“太持久”，已经默默的流失了众多客户。 所谓天下武功，唯快不破！想要设计更快的网页优化速度，我们可以借鉴成功的优化经验以及技术。 ##PC 端网站优化方案 不论在 PC 还是在移动浏览器上，只有不到 10% 的时间是用来读取页面的 HTML 的。剩下的 90% 是用来加载额外的像样式表、脚本文件、或者图片这样的资源和执行客户端的程序。因此，许多在 PC 端的传统网页优化方案在移动端仍然可行。比如说： 减少每个页面的 HTTP 请求数 将共用的 JavaScript 和 CSS 代码放在公共的文件夹中与多个页面共享 确保在一个页面中相同的脚本不会被加载多次。同时，将脚本中的 Click 事件改为 On Touch 事件来减少固有的 300ms 延迟 使用 CSS Sprites 来整合图像，将多张图片整合到一个线性的网状的大图片中 使用 Cache-Control 或者 Expires 标记来实现浏览器缓存，从而减少不必要的服务器请求，尽可能地从本地缓存中获取资源。 强大的自定义CSS功能，方便定制自己的展示 减少每个请求加载的大小 使用 gzip 这样的压缩技术来压缩图像和文本，依靠增加服务端压缩和浏览器解压的步骤，来减少资源的负载。 整合并压缩 CSS 与 JavaScript，删除不必要的字符与变量。 动态地调整图片大小或者将图片替换为移动设备专用的更小的版本。 分段加载和隐藏加载等手段，可以将不可见区域的内容延迟加载或暂时不需要的脚本进行延时读取 ##采用更优的 HTTP2 协议 多路复用技术带来的请求 - 响应加速 HTTP2 采用多路复用的技术，允许同时通过单一的 HTTP2 连接发起多重的请求响应消息，从而大大的加快了网页加载时间。 HTTP2 采用二进制格式传输数据，并把他们分割为更小的帧，相比于 HTTP/1.x 的文本格式传输更为方便。 HTTP1.x 的 header 由于 cookie 和 user agent 很容易膨胀，而且每次都要重复发送。HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量*Server Push 带来的更快的资源推送 通过 Server Push 功能，服务端可以主动把 JS 和 CSS 等文件发送给终端，而省去了解析 HTML 请求的过程。简单的说，当你需要访问某个文件的时候，它已经在乖乖的在后台躺好了。 点击查看原文链接","tags":[]},{"title":"欢迎来到我的博客","date":"2017-05-20T07:26:50.000Z","path":"2017/05/20/欢迎来到我的博客/","text":"欢迎来到我的博客、以后我将在这里分享我的技术博客、把我遇到的技术问题在这里跟大家分享，也希望大家能够提出批评和指正，欢迎多挑毛病多多尝试！","tags":[]}]