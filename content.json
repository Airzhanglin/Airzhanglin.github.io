[{"title":"简单的讲一讲es6常用的特效","date":"2017-07-24T16:28:00.000Z","path":"2017/07/25/es6_aticle/","text":"最近一段时间基本上忙着自己的事情，忙着学习vuex、webpack、es6还有要弄一个vue+nodejs+mysql搞一个简单点开源项目，也在研究微信小程序。正经的写博客也是头一次，利用这个时候写一篇博客试试，讲讲我学过后的es6一些知识。什么是ES6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。上个周在segmentfault社区里面看到推送的一周周刊里就说道es7已经在六月底就正式发布了，我看这是一年一个版本的节奏，只能说前端的技术更新太快。所以作为前端开发者的你还不关注新的技术那就out了，不会es6的基础用法都不太算是一名前端开发者了。 什么是Babel[Babel][1]是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看 ####let 和 const 命令在es6之前我们都是使用var来声明一个变量，在es6的时候新增了let、const命令，虽然这两个变量与var类似，但是实际运用中他俩都有各自的特殊用途。首先来看下面这个例子：1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用var声明的变量b在代码块之外还能得到1，但是用let定义的变量b在代码块之外却是报错。这是因为let声明的变量只在它所在的代码块有效let命令在for循环场景里面最适合不过了1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码使用var来声明那就不一样了1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require(&apos;moment&apos;) 变量结构（基础用法）ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。除了数组可以解构外还有对象解构，反正我觉得很方便（滑稽表情）123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 模板字符串（template string）这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，经常出现的场景就是使用jq append()的时候回写一大推，一不小心还可能写错，所以之前我们通常会引用一些模板工具库，比如mustache等等。传统的JavaScript语言，输出模板通常是这样写的。123456$(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; + &apos;items in your basket, &apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos;); ES6引入了模板字符串12345$(&apos;#result&apos;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。可能你在一些网友写的代码中看到，如果你看到了说明就是es的写法,这es6最常用的特效了。1var f = v =&gt; v; 等同于下面这种：123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; ####没有局部this的绑定和一般的函数不同，箭头函数不会绑定this。 或则说箭头函数不会改变this本来的绑定。我们用一个例子来说明：123456789101112function Counter() &#123; this.num = 0; this.timer = setInterval(function add() &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// NaN// NaN// NaN// ... 使用了关键字new构造，Count()函数中的this绑定到一个新的对象，并且赋值给a你会发现，每隔一秒都会有一个NaN打印出来，而不是累加的数字我们来尝试理解为什么出错：根据上一篇博客讲解的规则，首先函数setInterval没有被某个声明的对象调用，也没有使用new关键字，再之没有使用bind, call和apply。setInterval只是一个普通的函数。实际上setInterval里面的this绑定到全局对象的。我们可以通过将this打印出来验证这一点：12345678910function Counter() &#123; this.num = 0;this.timer = setInterval(function add() &#123; console.log(this); &#125;, 1000);&#125;var b = new Counter();//Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; 当我们用箭头函数就能解决这个问题12345678910111213function Counter() &#123; this.num = 0; this.timer = setInterval(() =&gt; &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// 1// 2// 3// ... 摘一下阮老师的教程：箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 set函数ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。1234567891011// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]//列二const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 以前我们取出数组里面的重复值会用到遍历，然后用indexOf方法去做: 123456789var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;] var arr2 = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr2.indexOf(arr[i])&lt;0)&#123; arr2.push(arr[i]); &#125; &#125; arr2.sort(); console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 如果用Set()来去除数组里面的重复值那就更加简单123var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;]var arr2 = [...new Set(arr)]console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 更多关于Set函数的属性和方法可以看阮老师的教程。再一次感谢您花费时间阅读这份没水平的文章，尝试第一次写好一点的博客，最近学习的es6，我觉得很多新特性在日常开发当中我们都可以用上，比如我现在很喜欢的前端框架Vue，FaceBook的react 都在使用es6，所以推荐大家使用起来，加快我们的开发效率。 欢迎吐槽。。。 2016 年 07月 25日","tags":[]},{"title":"想要提升移动网页的加载速度？你可以Get这些技能","date":"2017-06-19T13:41:03.000Z","path":"2017/06/19/new-article/","text":"在这个信息爆炸的时代，使用移动终端获取新鲜信息已经是大势所趋，但是移动网页浏览速度还有巨大的提升空间。据 Strangeloop Networks 统计，在同样的网络条件下，使用移动端访问相同网页平均会比 PC 端慢 40%！ 然而另一方面，用户对网速的要求却步步紧逼。Akamai 的研究表明，网页响应时间可容忍的阀值是 2 秒，一旦超过 3 秒，会有 40% 的用户放弃浏览页面。简而言之，作为内容服务商的你，可能因为移动网页的加载“太持久”，已经默默的流失了众多客户。 所谓天下武功，唯快不破！想要设计更快的网页优化速度，我们可以借鉴成功的优化经验以及技术。 ##PC 端网站优化方案 不论在 PC 还是在移动浏览器上，只有不到 10% 的时间是用来读取页面的 HTML 的。剩下的 90% 是用来加载额外的像样式表、脚本文件、或者图片这样的资源和执行客户端的程序。因此，许多在 PC 端的传统网页优化方案在移动端仍然可行。比如说： 减少每个页面的 HTTP 请求数 将共用的 JavaScript 和 CSS 代码放在公共的文件夹中与多个页面共享 确保在一个页面中相同的脚本不会被加载多次。同时，将脚本中的 Click 事件改为 On Touch 事件来减少固有的 300ms 延迟 使用 CSS Sprites 来整合图像，将多张图片整合到一个线性的网状的大图片中 使用 Cache-Control 或者 Expires 标记来实现浏览器缓存，从而减少不必要的服务器请求，尽可能地从本地缓存中获取资源。 强大的自定义CSS功能，方便定制自己的展示 减少每个请求加载的大小 使用 gzip 这样的压缩技术来压缩图像和文本，依靠增加服务端压缩和浏览器解压的步骤，来减少资源的负载。 整合并压缩 CSS 与 JavaScript，删除不必要的字符与变量。 动态地调整图片大小或者将图片替换为移动设备专用的更小的版本。 分段加载和隐藏加载等手段，可以将不可见区域的内容延迟加载或暂时不需要的脚本进行延时读取 ##采用更优的 HTTP2 协议 多路复用技术带来的请求 - 响应加速 HTTP2 采用多路复用的技术，允许同时通过单一的 HTTP2 连接发起多重的请求响应消息，从而大大的加快了网页加载时间。 HTTP2 采用二进制格式传输数据，并把他们分割为更小的帧，相比于 HTTP/1.x 的文本格式传输更为方便。 HTTP1.x 的 header 由于 cookie 和 user agent 很容易膨胀，而且每次都要重复发送。HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量*Server Push 带来的更快的资源推送 通过 Server Push 功能，服务端可以主动把 JS 和 CSS 等文件发送给终端，而省去了解析 HTML 请求的过程。简单的说，当你需要访问某个文件的时候，它已经在乖乖的在后台躺好了。 点击查看原文链接","tags":[]},{"title":"欢迎来到我的博客","date":"2017-05-20T07:26:50.000Z","path":"2017/05/20/欢迎来到我的博客/","text":"欢迎来到我的博客、以后我将在这里分享我的技术博客、把我遇到的技术问题在这里跟大家分享，也希望大家能够提出批评和指正，欢迎多挑毛病多多尝试！","tags":[]}]