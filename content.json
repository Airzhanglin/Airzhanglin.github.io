[{"title":"讲一讲如何使用DataTable","date":"2017-11-22T13:54:00.000Z","path":"2017/11/22/datatable/","text":"可能有人说现在第是使用前端三大框架来做项目，利用数据绑定来实现表格的操作极其方便快捷。但是没有接触过这三大框架的人多多少少有用过jq dataTable这个插件。我在进入前端这个方向的时候我直接接触了Angularjs了，利用双向数据绑定来做表格特别的方便快捷，后来换了公司，因为需要维护项目所以才接触这个jq插件。总得来说阅读过插件的API还是觉得挺方便的，毕竟别人都封装好了方法。但是中文网上的实例实在是少了，不够详细，想我等菜鸟只能是google了。如今对这个表格还算是挺熟悉的，所以记录下来，以便各位网友遇到问题是能够作为参考，也有不对之处敬请指出更正。 dataTablejQuery 的插件 dataTables 是一个优秀的表格插件，提供了针对表格的排序、浏览器分页、服务器分页、筛选、格式化等功能。dataTables 的网站上也提供了大量的演示和详细的文档进行说明，为了方便学习使用，这里一步一步进行说明。首先，需要到 dataTables(中文网点这里) 的网站 下载脚本库。 使用方法直接上代码： 引入css和js文件 1234567891011121314151617181920212223&lt;!DOCTYPE html&gt;&lt;html lang=\"en\"&gt;&lt;head&gt; &lt;meta charset=\"UTF-8\"&gt; &lt;meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0,maximum-scale=1.0,user-scalable=no\"&gt; &lt;meta http-equiv=\"X-UA-Compatible\" content=\"ie=edge\"&gt; &lt;link href=\"datatables/datatables.min.css\" rel=\"stylesheet\"&gt; &lt;link rel=\"stylesheet\" href=\"bootstrap/datatables.bootstrap.css\"&gt; &lt;title&gt;datatable&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;table class=\"table table-striped table-bordered table-hover table-checkable order-column\" id=\"News_article_table\"&gt; &lt;/table&gt; &lt;script src=\"jquery/jquery.min.js\"&gt;&lt;/script&gt; &lt;script src=\"datatables/datatables.min.js\"&gt;&lt;/script&gt; &lt;script src=\"/bootstrap/datatables.bootstrap.js\"&gt;&lt;/script&gt; &lt;script src=\"/controller/dataTatbalCtrl\"&gt;&lt;/script&gt;&lt;/body&gt; &lt;/html&gt; js文件（dataTatbalCtrl.js）：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576var News_article_table = $('#News_article_table').dataTable(&#123; ajax: &#123; url: 'url', type: 'get', data: null, dataType: 'json', scriptCharset: 'utf-8', async: false, dataSrc: function (result) &#123; localStorage.all = JSON.stringify(result.data); return result.data; &#125; &#125;, \"language\": &#123; \"aria\": &#123; \"sortAscending\": \": 升序排列\", \"sortDescending\": \": 降序排列\" &#125;, \"emptyTable\": \"没有数据显示\", \"info\": \"显示_START_ 到 _END_ 条/ 共_TOTAL_ 条\", \"infoEmpty\": \"没有搜索到结果\", \"infoFiltered\": \"\", \"lengthMenu\": \"&lt;span class='tab-page-show'&gt;显示&lt;/span&gt; _MENU_ &lt;span class='tab-page-show'&gt;条&lt;/span&gt;\", \"search\": \"&lt;span class='tab-search'&gt;查询&lt;/span&gt;\", \"zeroRecords\": \"没有匹配到数据\", \"paginate\": &#123; \"previous\": \"上页\", \"next\": \"下页\", \"last\": \"末页\", \"first\": \"首页\" &#125; &#125;, bStateSave: true, // 保存状态 - 在页面重新加载的时候恢复状态（页码等内容） lengthMenu: [ [5, 8, 10, 15, -1], [5, 8, 10, 15, \"全部\"] // change per page values here ], // set the initial value pageLength: 10, pagingType: \"bootstrap_full_number\", //去掉默认的排序三角形图标 order: [], columns: [ &#123; data: null, title: '&lt;label class=\"mt-checkbox mt-checkbox-single mt-checkbox-outline\"&gt;' + '&lt;input type=\"checkbox\" class=\"group-checkable\" data-set=\"#News_article_table .checkboxes\" /&gt;' + '&lt;span&gt;&lt;/span&gt;' + '&lt;/label&gt;', width: \"5%\", orderable: false //配合order:[] 屏蔽排序和三角图标 &#125;, &#123; data: \"null\",//服务器返回的 字段名，如果需要进行数据处理可以填写为null, title: \"基本信息\",//表头信息 width: \"25%\",//列宽 render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125; ], columnDefs: [&#123; //指定第第一列（check框） targets: 0, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;, &#123; // 指定第最后一列 targets: 7, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;] &#125;); 配置参数可看api文档，讲的也很详细。以上的是实现的是前端实现分页操作，服务器会把全部数据给你。一次性查找所需的所有数据（但对于若查找的数据有上万条效率太低）所以用服务器端动态分页：一次访问几条，多次访问后台数据； 服务器分页配置如果需要进行服务器分页的需要把serverSide设置为true,在上列的没有写该参数，默认情况时false，所以需要写入该参数；这里建议阅读http://www.datatables.club/manual/server-side.html123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384var News_article_table = $('#News_article_table').dataTable(&#123; \"bProcessing\":false,//是否显示处理状态(排序的时候，数据很多耗费时间长的话，也会显示这个) \"sAjaxSource\":'news/lists',//接口请求地址 \"serverSide\":true,//开启服务器模式 \"fnServerData\":function(sSource, aoData, fnCallback)&#123; var page = aoData[3].value/aoData[4].value; // console.log(page); var currenPage= page==Infinity?1:parseInt(page)+1; aoData.push(&#123;name:'currenPage',value:currenPage&#125;);//我个人添加这个当前页 $.ajax(&#123; url: sSource, type: 'get', data: aoData, dataType: 'json', scriptCharset: 'utf-8', async: false, success:function(resp)&#123; fnCallback(resp); &#125; &#125;); &#125;, \"language\": &#123; \"aria\": &#123; \"sortAscending\": \": 升序排列\", \"sortDescending\": \": 降序排列\" &#125;, \"emptyTable\": \"没有数据显示\", \"info\": \"显示_START_ 到 _END_ 条/ 共_TOTAL_ 条\", \"infoEmpty\": \"没有搜索到结果\", \"infoFiltered\": \"\", \"lengthMenu\": \"&lt;span class='tab-page-show'&gt;显示&lt;/span&gt; _MENU_ &lt;span class='tab-page-show'&gt;条&lt;/span&gt;\", \"search\": \"&lt;span class='tab-search'&gt;查询&lt;/span&gt;\", \"zeroRecords\": \"没有匹配到数据\", \"paginate\": &#123; \"previous\": \"上页\", \"next\": \"下页\", \"last\": \"末页\", \"first\": \"首页\" &#125; &#125;, bStateSave: false, // 保存状态 - 在页面重新加载的时候恢复状态（页码等内容） lengthMenu: [ [5, 8, 10, 15, -1], [5, 8, 10, 15, \"全部\"] // change per page values here ], // set the initial value pageLength: 10, pagingType: \"bootstrap_full_number\", //去掉默认的排序三角形图标 order: [], columns: [ &#123; data: null, title: '&lt;label class=\"mt-checkbox mt-checkbox-single mt-checkbox-outline\"&gt;' + '&lt;input type=\"checkbox\" class=\"group-checkable\" data-set=\"#News_article_table .checkboxes\" /&gt;' + '&lt;span&gt;&lt;/span&gt;' + '&lt;/label&gt;', width: \"5%\", orderable: false //配合order:[] 屏蔽排序和三角图标 &#125;, &#123; data: \"null\",//服务器返回的 字段名，如果需要进行数据处理可以填写为null, title: \"基本信息\",//表头信息 width: \"25%\",//列宽 render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125; ], columnDefs: [&#123; //指定第第一列（check框） targets: 0, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;, &#123; // 指定第最后一列 targets: 7, render: function (data, type, row, meta) &#123; //逻辑处理 &#125; &#125;]&#125;); 开启服务器处理模式，这时我们对表格的每次操作，datatable都会帮我们向服务器发起请求获取数据，默认是用GET方式传递参数，所以我们下面加上了”fnServerData”，这样可以修改参数传递的方式为POST，那么到底给服务端发送的”aoData”是个什么鬼呢，别急，我们直接从Servlet取出来看看就知道了我们在浏览器打开页面并打印aoData 12345678910111213141516171819202122232425 [&#123;“name”:”sEcho”,”value”:1&#125;, &#123;“name”:”iColumns”,”value”:3&#125;, &#123;“name”:”sColumns”,”value”:”,,”&#125;, &#123;“name”:”iDisplayStart”,”value”:0&#125;, &#123;“name”:”iDisplayLength”,”value”:10&#125;, &#123;“name”:”mDataProp_0”,”value”:”id”&#125;, &#123;“name”:”sSearch_0”,”value”:”“&#125;, &#123;“name”:”bRegex_0”,”value”:false&#125;, &#123;“name”:”bSearchable_0”,”value”:true&#125;, &#123;“name”:”bSortable_0”,”value”:true&#125;, &#123;“name”:”mDataProp_1”,”value”:”name”&#125;, &#123;“name”:”sSearch_1”,”value”:”“&#125;, &#123;“name”:”bRegex_1”,”value”:false&#125;, &#123;“name”:”bSearchable_1”,”value”:true&#125;, &#123;“name”:”bSortable_1”,”value”:true&#125;, &#123;“name”:”mDataProp_2”,”value”:”age”&#125;, &#123;“name”:”sSearch_2”,”value”:”“&#125;, &#123;“name”:”bRegex_2”,”value”:false&#125;, &#123;“name”:”bSearchable_2”,”value”:true&#125;, &#123;“name”:”bSortable_2”,”value”:true&#125;, &#123;“name”:”sSearch”,”value”:”“&#125;, &#123;“name”:”bRegex”,”value”:false&#125;, &#123;“name”:”iSortCol_0”,”value”:0&#125;, &#123;“name”:”sSortDir_0”,”value”:”asc”&#125;, &#123;“name”:”iSortingCols”,”value”:1&#125;] 刚刚开始看到这些数据我真的有点乱，一个分页查询看到有这么多参数sEcho：客户端发送请求同时发送过来的一个标识，虽然有什么卵用不知道，不过我们服务端返回的数据中必须带有这个标识，哦，官网的文档里说，服务端取出标识最好转一下转成int，防止XXS攻击（懵逼，暂且不管，我们只知道需要这个就行）iColumns：列数iDisplayStart：起始索引iDisplayLength：显示的行数{“name”:”mDataProp_0”,”value”:”id”},{“name”:”sSearch_0”,”value”:”“},{“name”:”bRegex_0”,”value”:false},{“name”:”bSearchable_0”,”value”:true},{“name”:”bSortable_0”,”value”:true}每一列的参数设置，_0即是第一列，这个我们不管，到下面也是提取列名而已sSearch：全局搜索字段iSortCol_0：被排序的列sSortDir_0：排序方式； 服务端必须返回的数据格式如下：123456&#123; draw:1,//必须 ，Datatables发送的draw是多少那么服务器就返回多少。 这里注意，作者出于安全的考虑，强烈要求把这个转换为整形，即数字后再返回，而不是纯粹的接受然后返回，这是 为了防止跨站脚本（XSS）攻击。也就上面的sEcho字段给了服务端多少，服务端就返回多少 recordsTotal:25,//即没有过滤的记录数（数据库里总共记录数） recordsFiltered:25, // 过滤后的记录数（如果有接收到前台的过滤条件，则返回的是过滤后的记录数） data:[]&#125; 至此服务端分页完成。以上是根据中文网提供的api文档以及网友提供的方法总结出来的，总体是还是很乱，因为中文网api所提供的参数与网友所提供的api参数并不一致，但是在我这里却都可以。也有可能是文件版本的问题。如果有其它疑问可以给我留言。","tags":[{"name":"jqdatatable","slug":"jqdatatable","permalink":"http://yoursite.com/tags/jqdatatable/"}]},{"title":"hexo Yilia 主题如何添加相册功能","date":"2017-11-05T14:27:35.000Z","path":"2017/11/05/2017-11-5相册教程/","text":"如果你拥有hexo搭建的博客，然后使用也是Yilia主题的应该知道Yilia主题会有一个相册的。我也是使用的这一套主题，然后也很想搞一个相册，在Yilia主题的作者 Litten的github上留言问了如何实现这一个功能，作者也没有详细说明，我这里根据网友提供的方法来实现的。这里贴一下链接吧：点击这里可能更加详细。自己整理了一下思路： 在主页上必须有一个可供点击的相册链接 要用 hexo 生成一个 photos.html 文件 photos.html 中的图片数据来源?因为这是一个静态页面所有要有一个 json 文件，其实就是ajax请求json文件来渲染的 json 文件中有含有信息,图片的文件名. 图片要有一个完整的路径,把图片放到哪呢?七牛的图床,github 的空间,自己的服务器都可以. .怎么上传呢?大量图片当然写脚本传了.不会写咋办?很多人都写好了,改改就是了,脚本也有很多个版本.多数用 nodeJS写的,hexo 就用的 nodeJS.Python也是很不错的选择. 准备两套图片，一套大图(原图)，一套小图（缩率） 通过hexo d来生成相册页面 1. 提供一个可点击的链接。 1.进入你的博客目录下通过命令 hexo new page “photos”就会在source目录下生成photos这个文件夹 2.配置 Yilia 主题让其显示出来. yourBlog/themes/yilia/_config.yml文件中这样设置 12主页: /相册: photos 2. 如何生成一个photos.html这个文件 1.这里我也不知道具体如何生成，具体的代码我没有去看，因为我认为这仅仅是一个工具。所以我直接下载了作者的文件。下载地址，你也可以下载我的备份文件 2.这里就是放相册资源的目录，我是模仿作者的目录来的，具体的文件中怎么写可以直接参考Yilia主题的作者，我是直接拷贝下来的。说明一下:data.json这个文件开始是不存在。ejs 文件是以后要hexo 文件渲染的文件.assets 目录是放默认图片的也要有.3.index.ejs文件可以修改也可以不修改，作者里是把评论的功能去掉了。而我把comments设置了true。4.修改 ins.js 文件的 render()函数.这个函数是用来渲染数据的修改图片的路径地址.minSrc 小图的路径. src 大图的路径.修改为自己的图片路径(七牛的, github的路径).![此处输入图片的描述][4]上面的代码只需要修改路劲就可以了。我在这里遇到一个坑，我下载了作者的代码，只修改了minSrc 和src这个路劲，但是最后发现缩略图没法显示，我在浏览器审查的时候发现，figure标签下的img标签的src路劲的地址不对，所我做了更改，直接把修改了minSrc. 3. 生成json文件 这一步是关键的一步,也是最后一步.先用脚本把图片处理成一套大图和一套小图,所以你需要在你的博客目录下准备如下图所示的文件 ![此处输入图片的描述][5]你把图片都放在这个文件之后执行python脚本后就会生成json文件的。然后把图片再上传的七牛或者 github 上每次更新图片都要执行脚本重新生成 json 文件.这个json 文件会出现在yourBlog/source/photos/data.json图片如何命名，然后显示日期，这里可以看这位博主的点击查看 4. 处理图片我用的别人写好的脚本,看他写得已经很全了,我也懒得再写了.改改就好了.[脚本下载地址][6].py 文件就是 Python 的脚本.脚本的内容我就不讲了，因为我也不懂python语法，开始我下载下来然后执行的时候报错，折腾了很久才搞定的，要修改的地方就是： 173行的git_operation()方法，这个方法是把图片上传至github的，然如果你图片确实是放在github上，那就没必要注释掉。而我这里是放在七牛上的，所以用不到该方法。 大概131行这里，我执行脚本的时候报错了，源码上写的是../lawlite19.github.io/source/photos/data.json是对应到作者的博客的路径，这里根据需要改成自己博客的路径。而我这里更改成了本地 source/phontos。最后就是执行脚本的功夫了 5. 可能出现的问题（我是出现过的） 在命令行执行python too.py 命令的时候出现no module named PIL错误百度后知道出现这错误的原因是: PIL 模块找不到,PIL 模块已经过时了.解决方案: 安装 pip install pillow（cmd执行该命令就好了）关于Python如何安装，建议谷歌或者百度。 6. 如何执行 cmd切换到你的博客目录下，然后执行 python tool.py(处理图片,上传图片,生成 json 文件)hexo clean (清理之前的 HTML 等)hexo g (生成 HTML 文件)hexo s (看看效果如何)最后部署到你的博客上.网上大致文章都是这么的写,找到一个差不多就开始实践吧,如果你看我的去实践遇到问题可以找我,我只要有时间定会回复你.如果遇见更多的坑欢迎补充(github提问,博客评论, QQ 加好友都可以哦)✌️","tags":[]},{"title":"vue集成百度Ueditor富文本编辑器","date":"2017-07-25T13:54:00.000Z","path":"2017/07/25/vue-ueditor/","text":"有使用vue来开发项目可能使用一下较为简单的富文本编辑器，功能不是很全面。如果涉及到自媒体运营类的系统Ueditor再适合不过了。网上的富文本编辑器众多，比如：wangEditor 、Simditor 、tinymce等。富文本编辑器设计到的知识面特别广，如果你想自己做简单的nname也可以、利用HTML5中的属性contenteditable，把他放在div上设为true时便可以编辑，但是坑也很多。你可以点击为什么说富文本编辑器是天坑这里来看看大神们的回答。这里只讲讲在vue项目中如何集成ueditor，如果你有这个需求希望可以帮助到你效果图如下： 1、 首先使用vue-cli脚手架建立一个vue工程，然后去ueditor官网下载源码。地址：http://ueditor.baidu.com/website/ 。把项目复制到vue项目的static文件下。目的是让服务可以访问到里面的文件，打开UEditor目录文件，我这里下载的是nodejs版本的； 项目结构如下： 2、然后再main.js中引入js文件 import &apos;../static/ueditor/ueditor.config&apos; import &apos;../static/ueditor/ueditor.all&apos; import &apos;../static/ueditor/lang/zh-cn/zh-cn&apos; import &apos;../static/ueditor/ueditor.parse.min&apos; 3、创建组件。在components文件里面创建.vue文件，命名随便你。我这里是命名为ueditor.vue。 &lt;template&gt; &lt;el-row&gt; &lt;el-col :span=&quot;18&quot; :offset=&quot;3&quot;&gt; &lt;div class=gird-content&gt; &lt;div id=&quot;editor&quot; type=&quot;text/plain&quot; style=&quot;width:1024px;height:500px;&quot;&gt;&lt;/div&gt; &lt;el-button type=&quot;info&quot; @click=&quot;getUedtorContent&quot;&gt;保存&lt;/el-button&gt; &lt;/div&gt; &lt;/el-col&gt; &lt;/el-row&gt; &lt;/template&gt; &lt;script&gt; import ElButton from &quot;../../node_modules/element-ui/packages/button/src/button&quot;; export default{ components: {ElButton}, name: &apos;addnew&apos;, data () { return { input: &apos;&apos;, editor: null } }, mounted () { this.editor =UE.getEditor(&apos;editor&apos;, { UEDITOR_HOME_URL: &apos;/static/ueditor/&apos;,//配置资源路径 toolbars: [ [ &apos;anchor&apos;, //锚点 &apos;undo&apos;, //撤销 &apos;redo&apos;, //重做 &apos;bold&apos;, //加粗 &apos;indent&apos;, //首行缩进 &apos;snapscreen&apos;, //截图 &apos;italic&apos;, //斜体 &apos;underline&apos;, //下划线 &apos;strikethrough&apos;, //删除线 &apos;subscript&apos;, //下标 &apos;fontborder&apos;, //字符边框 &apos;superscript&apos;, //上标 &apos;formatmatch&apos;, //格式刷 &apos;source&apos;, //源代码 &apos;blockquote&apos;, //引用 &apos;pasteplain&apos;, //纯文本粘贴模式 &apos;selectall&apos;, //全选 &apos;print&apos;, //打印 &apos;preview&apos;, //预览 &apos;horizontal&apos;, //分隔线 &apos;removeformat&apos;, //清除格式 &apos;time&apos;, //时间 &apos;date&apos;, //日期 &apos;unlink&apos;, //取消链接 &apos;insertrow&apos;, //前插入行 &apos;insertcol&apos;, //前插入列 &apos;mergeright&apos;, //右合并单元格 &apos;mergedown&apos;, //下合并单元格 &apos;deleterow&apos;, //删除行 &apos;deletecol&apos;, //删除列 &apos;splittorows&apos;, //拆分成行 &apos;splittocols&apos;, //拆分成列 &apos;splittocells&apos;, //完全拆分单元格 &apos;deletecaption&apos;, //删除表格标题 &apos;inserttitle&apos;, //插入标题 &apos;mergecells&apos;, //合并多个单元格 &apos;deletetable&apos;, //删除表格 &apos;cleardoc&apos;, //清空文档 &apos;insertparagraphbeforetable&apos;, //&quot;表格前插入行&quot; &apos;insertcode&apos;, //代码语言 &apos;fontfamily&apos;, //字体 &apos;fontsize&apos;, //字号 &apos;paragraph&apos;, //段落格式 &apos;simpleupload&apos;, //单图上传 &apos;insertimage&apos;, //多图上传 &apos;edittable&apos;, //表格属性 &apos;edittd&apos;, //单元格属性 &apos;link&apos;, //超链接 &apos;emotion&apos;, //表情 &apos;spechars&apos;, //特殊字符 &apos;searchreplace&apos;, //查询替换 &apos;map&apos;, //Baidu地图 &apos;gmap&apos;, //Google地图 &apos;insertvideo&apos;, //视频 &apos;help&apos;, //帮助 &apos;justifyleft&apos;, //居左对齐 &apos;justifyright&apos;, //居右对齐 &apos;justifycenter&apos;, //居中对齐 &apos;justifyjustify&apos;, //两端对齐 &apos;forecolor&apos;, //字体颜色 &apos;backcolor&apos;, //背景色 &apos;insertorderedlist&apos;, //有序列表 &apos;insertunorderedlist&apos;, //无序列表 &apos;fullscreen&apos;, //全屏 &apos;directionalityltr&apos;, //从左向右输入 &apos;directionalityrtl&apos;, //从右向左输入 &apos;rowspacingtop&apos;, //段前距 &apos;rowspacingbottom&apos;, //段后距 &apos;pagebreak&apos;, //分页 &apos;insertframe&apos;, //插入Iframe &apos;imagenone&apos;, //默认 &apos;imageleft&apos;, //左浮动 &apos;imageright&apos;, //右浮动 &apos;attachment&apos;, //附件 &apos;imagecenter&apos;, //居中 &apos;wordimage&apos;, //图片转存 &apos;lineheight&apos;, //行间距 &apos;edittip &apos;, //编辑提示 &apos;customstyle&apos;, //自定义标题 &apos;autotypeset&apos;, //自动排版 &apos;webapp&apos;, //百度应用 &apos;touppercase&apos;, //字母大写 &apos;tolowercase&apos;, //字母小写 &apos;background&apos;, //背景 &apos;template&apos;, //模板 &apos;scrawl&apos;, //涂鸦 &apos;music&apos;, //音乐 &apos;inserttable&apos;, //插入表格 &apos;drafts&apos;, // 从草稿箱加载 &apos;charts&apos;, // 图表 ] ], autoHeightEnabled: true, autoFloatEnabled: true, minFrameHeight: 500, }); }, destroyed(){ this.editor.destroy(); }, methods:{ getUedtorContent: function () { console.log(this.editor.getContent()); } } } &lt;/script&gt; 4、在你想要显示第view中引入该组件即可。 关于上传地址配置需要在ueditot.config.js文件里面进行配置。这里也需要后端配置，具体实现可以在uedtor文档上进行查看。贴上我这里的代码：ueditot.config.js中：serverUrl: “/ue” // 服务器统一请求接口路径后端接口： app.use(&quot;/ue&quot;, ueditor(path.join(__dirname,&apos;/public&apos;), function (req, res, next) { //客户端上传文件设置 var imgDir = &apos;/img/ueditor/&apos;; var ActionType = req.query.action; if (ActionType === &apos;uploadimage&apos; || ActionType === &apos;uploadfile&apos; || ActionType === &apos;uploadvideo&apos;) { var file_url = imgDir;//默认图片上传地址 /*其他上传格式的地址*/ if (ActionType === &apos;uploadfile&apos;) { file_url = &apos;/file/ueditor/&apos;; //附件 } if (ActionType === &apos;uploadvideo&apos;) { file_url = &apos;/video/ueditor/&apos;; //视频 } res.ue_up(file_url); //你只要输入要保存的地址 。保存操作交给ueditor来做 res.setHeader(&apos;Content-Type&apos;, &apos;text/html&apos;); } // 客户端发起图片列表请求 else if (req.query.action === &apos;listimage&apos;) { var dir_url = imgDir; res.ue_list(dir_url); // 客户端会列出 dir_url 目录下的所有图片 } // 客户端发起其它请求 else { // console.log(&apos;config.json&apos;) res.setHeader(&apos;Content-Type&apos;, &apos;application/json&apos;); res.redirect(&apos;/static/ueditor/nodejs/config.json&apos;); } })); 需要注意的是资源路径容易搞错。使用相对路径即可 以上都是个人在开发过程中遇到的问题然后根据网友提供的方法再自己整理出来，然后记录下来的。希望对大家有所帮忙。","tags":[]},{"title":"简单的讲一讲es6常用的特性","date":"2017-07-24T16:28:00.000Z","path":"2017/07/25/es6_aticle/","text":"最近一段时间基本上忙着自己的事情，忙着学习vuex、webpack、es6还有要弄一个vue+nodejs+mysql搞一个简单点开源项目，也在研究微信小程序。正经的写博客也是头一次，利用这个时候写一篇博客试试，讲讲我学过后的es6一些知识。 什么是ES6 ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在2015年6月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。因为当前版本的ES6是在2015年发布的，所以又称ECMAScript 2015。 虽然目前并不是所有浏览器都能兼容ES6全部特性，但越来越多的程序员在实际项目当中已经开始使用ES6了。上个周在segmentfault社区里面看到推送的一周周刊里就说道es7已经在六月底就正式发布了，我看这是一年一个版本的节奏，只能说前端的技术更新太快。所以作为前端开发者的你还不关注新的技术那就out了，不会es6的基础用法都不太算是一名前端开发者了。 什么是BabelBabel是一个广泛使用的ES6转码器，可以将ES6代码转为ES5代码，从而在现有环境执行。大家可以选择自己习惯的工具来使用使用Babel，具体过程可直接在Babel官网查看 ####let 和 const 命令在es6之前我们都是使用var来声明一个变量，在es6的时候新增了let、const命令，虽然这两个变量与var类似，但是实际运用中他俩都有各自的特殊用途。首先来看下面这个例子：1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 使用var声明的变量b在代码块之外还能得到1，但是用let定义的变量b在代码块之外却是报错。这是因为let声明的变量只在它所在的代码块有效let命令在for循环场景里面最适合不过了1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码使用var来声明那就不一样了1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var声明的，在全局范围内都有效。所以每一次循环，新的i值都会覆盖旧值，导致最后输出的是最后一轮的i的值。而使用let则不会出现这个问题。 const也用来声明变量，但是声明的是常量。一旦声明，常量的值就不能改变。12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 当我们尝试去改变用const声明的常量时，浏览器就会报错。const有一个很好的应用场景，就是当我们引用第三方库的时声明的变量，用const来声明可以避免未来不小心重命名而导致出现bug：1const monent = require(&apos;moment&apos;) 变量结构（基础用法）ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];third // &quot;baz&quot;let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = [&apos;a&apos;];x // &quot;a&quot;y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。除了数组可以解构外还有对象解构，反正我觉得很方便（滑稽表情）123let &#123; foo, bar &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot; 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。123456let &#123; bar, foo &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;foo // &quot;aaa&quot;bar // &quot;bbb&quot;let &#123; baz &#125; = &#123; foo: &quot;aaa&quot;, bar: &quot;bbb&quot; &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。如果变量名与属性名不一致，必须写成下面这样。1234567var &#123; foo: baz &#125; = &#123; foo: &apos;aaa&apos;, bar: &apos;bbb&apos; &#125;;baz // &quot;aaa&quot;let obj = &#123; first: &apos;hello&apos;, last: &apos;world&apos; &#125;;let &#123; first: f, last: l &#125; = obj;f // &apos;hello&apos;l // &apos;world&apos; 模板字符串（template string）这个东西也是非常有用，当我们要插入大段的html内容到文档中时，传统的写法非常麻烦，经常出现的场景就是使用jq append()的时候回写一大推，一不小心还可能写错，所以之前我们通常会引用一些模板工具库，比如mustache等等。传统的JavaScript语言，输出模板通常是这样写的。123456$(&apos;#result&apos;).append( &apos;There are &lt;b&gt;&apos; + basket.count + &apos;&lt;/b&gt; &apos; + &apos;items in your basket, &apos; + &apos;&lt;em&gt;&apos; + basket.onSale + &apos;&lt;/em&gt; are on sale!&apos;); ES6引入了模板字符串12345$(&apos;#result&apos;).append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 箭头函数ES6 允许使用“箭头”（=&gt;）定义函数。可能你在一些网友写的代码中看到，如果你看到了说明就是es的写法,这es6最常用的特效了。1var f = v =&gt; v; 等同于下面这种：123var f = function(v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; ####没有局部this的绑定和一般的函数不同，箭头函数不会绑定this。 或则说箭头函数不会改变this本来的绑定。我们用一个例子来说明：123456789101112function Counter() &#123; this.num = 0; this.timer = setInterval(function add() &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// NaN// NaN// NaN// ... 使用了关键字new构造，Count()函数中的this绑定到一个新的对象，并且赋值给a你会发现，每隔一秒都会有一个NaN打印出来，而不是累加的数字我们来尝试理解为什么出错：首先函数setInterval没有被某个声明的对象调用，也没有使用new关键字，再之没有使用bind, call和apply。setInterval只是一个普通的函数。实际上setInterval里面的this绑定到全局对象的。我们可以通过将this打印出来验证这一点：12345678910function Counter() &#123; this.num = 0;this.timer = setInterval(function add() &#123; console.log(this); &#125;, 1000);&#125;var b = new Counter();//Window &#123;speechSynthesis: SpeechSynthesis, caches: CacheStorage, localStorage: Storage, sessionStorage: Storage, webkitStorageInfo: DeprecatedStorageInfo…&#125; 当我们用箭头函数就能解决这个问题12345678910111213function Counter() &#123; this.num = 0; this.timer = setInterval(() =&gt; &#123; this.num++; console.log(this.num); &#125;, 1000);&#125;var b = new Counter();// 1// 2// 3// ... 摘一下阮老师的教程：箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。 set函数ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。 Set 本身是一个构造函数，用来生成 Set 数据结构。1234567891011// 例一const set = new Set([1, 2, 3, 4, 4]);[...set]// [1, 2, 3, 4]//列二const s = new Set();[2, 3, 5, 4, 5, 2, 2].forEach(x =&gt; s.add(x));for (let i of s) &#123; console.log(i);&#125;// 2 3 5 4 以前我们取出数组里面的重复值会用到遍历，然后用indexOf方法去做: 123456789var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;] var arr2 = []; for(var i = 0;i&lt;arr.length;i++)&#123; if(arr2.indexOf(arr[i])&lt;0)&#123; arr2.push(arr[i]); &#125; &#125; arr2.sort(); console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 如果用Set()来去除数组里面的重复值那就更加简单123var arr = [&apos;a&apos;,&apos;c&apos;,&apos;b&apos;,&apos;d&apos;,&apos;a&apos;,&apos;b&apos;]var arr2 = [...new Set(arr)]console.log(arr2);//[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;] 更多关于Set函数的属性和方法可以看阮老师的教程。再一次感谢您花费时间阅读这份没水平的文章，尝试第一次写好一点的博客，最近学习的es6，我觉得很多新特性在日常开发当中我们都可以用上，比如我现在很喜欢的前端框架Vue，FaceBook的react 都在使用es6，所以推荐大家使用起来，加快我们的开发效率。 欢迎吐槽。。。 2016 年 07月 25日","tags":[]},{"title":"想要提升移动网页的加载速度？你可以Get这些技能","date":"2017-06-19T13:41:03.000Z","path":"2017/06/19/new-article/","text":"在这个信息爆炸的时代，使用移动终端获取新鲜信息已经是大势所趋，但是移动网页浏览速度还有巨大的提升空间。据 Strangeloop Networks 统计，在同样的网络条件下，使用移动端访问相同网页平均会比 PC 端慢 40%！ 然而另一方面，用户对网速的要求却步步紧逼。Akamai 的研究表明，网页响应时间可容忍的阀值是 2 秒，一旦超过 3 秒，会有 40% 的用户放弃浏览页面。简而言之，作为内容服务商的你，可能因为移动网页的加载“太持久”，已经默默的流失了众多客户。 所谓天下武功，唯快不破！想要设计更快的网页优化速度，我们可以借鉴成功的优化经验以及技术。 ##PC 端网站优化方案 不论在 PC 还是在移动浏览器上，只有不到 10% 的时间是用来读取页面的 HTML 的。剩下的 90% 是用来加载额外的像样式表、脚本文件、或者图片这样的资源和执行客户端的程序。因此，许多在 PC 端的传统网页优化方案在移动端仍然可行。比如说： 减少每个页面的 HTTP 请求数 将共用的 JavaScript 和 CSS 代码放在公共的文件夹中与多个页面共享 确保在一个页面中相同的脚本不会被加载多次。同时，将脚本中的 Click 事件改为 On Touch 事件来减少固有的 300ms 延迟 使用 CSS Sprites 来整合图像，将多张图片整合到一个线性的网状的大图片中 使用 Cache-Control 或者 Expires 标记来实现浏览器缓存，从而减少不必要的服务器请求，尽可能地从本地缓存中获取资源。 强大的自定义CSS功能，方便定制自己的展示 减少每个请求加载的大小 使用 gzip 这样的压缩技术来压缩图像和文本，依靠增加服务端压缩和浏览器解压的步骤，来减少资源的负载。 整合并压缩 CSS 与 JavaScript，删除不必要的字符与变量。 动态地调整图片大小或者将图片替换为移动设备专用的更小的版本。 分段加载和隐藏加载等手段，可以将不可见区域的内容延迟加载或暂时不需要的脚本进行延时读取 ##采用更优的 HTTP2 协议 多路复用技术带来的请求 - 响应加速 HTTP2 采用多路复用的技术，允许同时通过单一的 HTTP2 连接发起多重的请求响应消息，从而大大的加快了网页加载时间。 HTTP2 采用二进制格式传输数据，并把他们分割为更小的帧，相比于 HTTP/1.x 的文本格式传输更为方便。 HTTP1.x 的 header 由于 cookie 和 user agent 很容易膨胀，而且每次都要重复发送。HTTP/2 对消息头采用 HPACK 进行压缩传输，能够节省消息头占用的网络的流量*Server Push 带来的更快的资源推送 通过 Server Push 功能，服务端可以主动把 JS 和 CSS 等文件发送给终端，而省去了解析 HTML 请求的过程。简单的说，当你需要访问某个文件的时候，它已经在乖乖的在后台躺好了。 点击查看原文链接","tags":[]},{"title":"欢迎来到我的博客","date":"2017-05-20T07:26:50.000Z","path":"2017/05/20/欢迎来到我的博客/","text":"欢迎来到我的博客、以后我将在这里分享我的技术博客、把我遇到的技术问题在这里跟大家分享，也希望大家能够提出批评和指正，欢迎多挑毛病多多尝试！","tags":[]}]